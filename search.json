[{"title":"디스코드 포럼에 Github 알림 받기","url":"/2023/10/16/Creating-Github-webhook-logs-with-discord-forums/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL:DR\"></a>TL:DR</h2><p>디스코드에 포럼 기능이 생겼다. 이제 주제별로 글을 쓰고 스레드를 남길 수 있다. 이전에는 깃허브 웹후크을 연동할 때 마다 하나의 채팅방에 여러개의 메시지가 섞이거나 여러개의 채팅방을 만들어야 했는데 이제 주제별로 포스트를 생성해 스레드로 남기면 된다!!!</p>\n<h2 id=\"포럼-채널에-웹후크-만들기\"><a href=\"#포럼-채널에-웹후크-만들기\" class=\"headerlink\" title=\"포럼 채널에 웹후크 만들기\"></a>포럼 채널에 웹후크 만들기</h2><p><code>채널 설정</code> &gt; <code>연동</code> &gt; <code>웹후크</code>에서 웹후크를 추가한다. <code>웹후크 URL 복사</code>를 클릭한다. <code>웹후크 URL</code>은 나중에 사용하기 때문에 따로 저장을 해둔다.<br><img src=\"/images/image.webp\" alt=\"Alt text\"></p>\n<h2 id=\"포스트-작성\"><a href=\"#포스트-작성\" class=\"headerlink\" title=\"포스트 작성\"></a>포스트 작성</h2><p>알림을 받을 포스트를 작성한다. 그 후 <code>스레드ID 복사하기</code>를 클릭한다. 이 <code>스레드 ID</code>도 나중에 사용하기에 따로 저장을 해둔다.<br><img src=\"/images/image-1.webp\" alt=\"Alt text\"></p>\n<blockquote>\n<p>개발자 모드가 활성화 상태여야 합니다.</p>\n</blockquote>\n<h2 id=\"Github-repository에-웹후크-추가하기\"><a href=\"#Github-repository에-웹후크-추가하기\" class=\"headerlink\" title=\"Github repository에 웹후크 추가하기\"></a>Github repository에 웹후크 추가하기</h2><p>Github의 리포지토리로 이동하여 <code>Setting</code> &gt; <code>Webhooks</code>에서 웹후크를 추가한다.<br><img src=\"/images/image-2.webp\" alt=\"Alt text\"></p>\n<ol>\n<li><code>Add webhook</code>를 클릭한다.</li>\n<li>Payload URL에 <code>WEBHOOK_URL/github?thread_id=POST_ID</code>를 입력한다. 이전에 저장한 값을 이용하면 된다.<ul>\n<li><code>WEBHOOK_URL</code> : <code>웹후크 URL</code></li>\n<li><code>POST_ID</code> : <code>스레드 ID</code></li>\n</ul>\n</li>\n<li>콘텐츠 유형으로 <code>application/json</code>을 선택한다.</li>\n</ol>\n<p><code>Which events would you like to trigger this webhook?</code> 에서 <code>Just the push event.</code>를 체크했다. 푸시될 때마다 메시지를 보내고 싶기 때문이다.</p>\n<p>완료되면 <code>Add webhook</code> 버튼을 클릭한다.</p>\n<h2 id=\"Finish\"><a href=\"#Finish\" class=\"headerlink\" title=\"Finish\"></a>Finish</h2><p><img src=\"/images/image-3.webp\" alt=\"Alt text\"><br>이제 푸시되면 해당 포스트에 메시지가 날라온다!</p>\n","categories":["etc"],"tags":["github","webhook","discord"]},{"title":"GitHub Issue를 기반으로 새 브랜치 생성하기 - Alias 활용 방법","url":"/2024/04/10/github-issue-new-branch-bash-alias/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL:DR\"></a>TL:DR</h2><p>GitHub 프로젝트에서 작업할 때, issue를 사용하여 작업 항목을 추적하고 관리하기로 마음 먹었다. issue와 연관된 작업을 수행하기 위해 새로운 브랜치를 만들어야 하는데 이 과정을 더욱 편하게 하기 위해 alias를 사용하여 GitHub issue를 기반으로 새로운 브랜치를 만들도록 했다.</p>\n<p><img src=\"/../images/github-issue-new-branch-bash-alias.md/img.webp\" alt=\"alt text\"></p>\n<h2 id=\"필수-설치-사항\"><a href=\"#필수-설치-사항\" class=\"headerlink\" title=\"필수 설치 사항\"></a>필수 설치 사항</h2><ul>\n<li>GitHub CLI : GitHub의 기능을 커맨드 라인에서 사용할 수 있도록 도와주는 도구.</li>\n<li>fzf : 터미널에서 상호작용적인 검색을 제공하는 유용한 도구.</li>\n<li>Git</li>\n</ul>\n<h2 id=\"git-alias-설정\"><a href=\"#git-alias-설정\" class=\"headerlink\" title=\"git alias 설정\"></a>git alias 설정</h2><p>먼저, 다음과 같이 <code>.gitconfig</code> 파일에 alias를 정의한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">[alias]<br>    icb = &quot;!f() &#123; gh issue list | fzf --ansi | awk -F&#x27;\\\\t&#x27; &#x27;&#123;gsub(\\&quot; \\&quot;, \\&quot;_\\&quot;, $3); print $1\\&quot;-\\&quot;$3&#125;&#x27; | xargs -I &#123;&#125; git checkout -b &#123;&#125;; &#125;; f&quot;<br></code></pre></td></tr></table></figure>\n<p><code>git icb</code> 명령을 실행하면, GitHub issue 목록을 검색하고 선택한 issue를 기반으로 브랜치를 만들 수 있다.</p>\n<h2 id=\"코드-설명\"><a href=\"#코드-설명\" class=\"headerlink\" title=\"코드 설명\"></a>코드 설명</h2><p>이 코드는 다음과 같은 작업을 수행한다.</p>\n<ol>\n<li><p><code>gh issue list</code> 명령을 사용하여 현재 GitHub 프로젝트의 issue 목록을 가져옵니다.</p>\n</li>\n<li><p><code>fzf</code>를 사용하여 사용자에게 issue 목록을 선택하도록 합니다.</p>\n</li>\n<li><p>사용자가 선택한 issue의 번호와 제목을 <code>awk</code>를 사용하여 적절한 형식으로 가공합니다.</p>\n<p> 이 단계에서는 <code>awk</code> 명령을 사용하여 사용자가 선택한 issue의 번호와 제목을 가공한다. <code>-F</code> 옵션을 사용하여 입력 필드 구분자를 설정하고, <code>$1</code>과 <code>$3</code>를 사용하여 선택한 issue의 번호와 제목에 접근했다. 그런 다음, <code>gsub()</code> 함수를 사용하여 제목에서 공백을 밑줄(_)로 대체하여 브랜치 이름으로 사용할 수 있도록 했다. 최종적으로, <code>print</code> 함수를 사용하여 적절한 형식으로 가공된 문자열을 출력하도록 했다.</p>\n</li>\n<li><p>최종적으로 <code>git checkout -b</code> 명령을 사용하여 선택한 issue를 기반으로 새로운 브랜치를 만든다.</p>\n</li>\n</ol>\n<h2 id=\"여담\"><a href=\"#여담\" class=\"headerlink\" title=\"여담\"></a>여담</h2><p>사실 커맨드 라인에 다음과 같은 명령어를 쳐도 된다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">gh issue list | fzf --ansi | awk -F&#x27;\\t&#x27; &#x27;&#123;gsub(&quot; &quot;, &quot;_&quot;, $3); print $1&quot;-&quot;$3&#125;&#x27; | xargs -I &#123;&#125; git checkout -b &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>하지만 이럴 경우 너무 길고, 불편하기 때문에 git alias에 등록하고 했다. git alias를 사용하면 내가 원하는 축약된 이름으로 위의 명령어를 사용할 수 있다고 생각했기 때문이다.</p>\n<p>하지만 git alias에서 이 명령어가 통하지 않았다. ㅠㅠ 여기저기 찾아보고 ai의 도움도 받았다.</p>\n<p>여기서(<a href=\"https://johngrib.github.io/wiki/git-alias/#%EC%9D%BC%ED%9A%8C%EC%9A%A9-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EC%9C%BC%EB%A1%9C-%EB%B3%B5%EC%9E%A1%ED%95%9C-%EC%85%B8-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0\">링크</a>) 함수를 선언 후 사용할 수 있다고 했길래, <code>f()</code>라는 함수로 감싸서 실행시켰다. </p>\n<p>그 다음 문제점은 바로 터미널에서 실행했을 때는 상관없었지만, alias 파일에 등록할 때는 <code>&quot; &quot;</code>로 감싸야했다. 하지만 나는 <code>&quot; &quot;</code>를 사용했기 때문에 꼬이기 시작한 것이다. 이부분에 대해서는 <code>\\</code>를 사용하면 해결된다는 것을 알기 때문에 쉽게 해결할 수 있었다. c&#x2F;c++ 코딩하면서 얻은 경험치가 여기서 사용이 되다니! 아무튼 <code>\\&quot;</code>가 <code>&quot;</code>가 문자열의 일부라는 것을 알려주는 것이기에 되는 것이다.</p>\n<p>그 외에 다른 명령어들은 chat gpt한테 물어본 후 함수를 알고 그 함수를 이것저것 테스트하면서 내가 원하는 형식으로 만들 수 있게 되었다. 아마 수십번 테스트 한 것이다. 언제 한번 본격적으로 배워야하는데 미루고 있다.</p>\n<p>위에는 살짝 가식은 섞은 것이고, 진짜 이유는 맥북에 모니터를 연결하지 못할 경우, 크롬 켰다, vscode 켰다 하는게 귀찮아서 CLI로 해결하자는 마음이 거대해졌기 때문이다.</p>\n<p>그리고 <code>fzf</code>를 사용해보고, 왠지 모르게 나의 도전욕구를 건드리고 있다. 많은 아이디어를 생각나게 하는 것은 오랜만인걸. 결과도 바로바로 볼 수 있어서 좋다.</p>\n<p>이만 여담은 마치고, 또 재미있거나 유용한 것 만들면 다시 나타날 것이다.</p>\n","tags":["github","alias","CLI"]},{"title":"Windows에서 Visual Studio Code로 C++ 개발 환경 설정하기","url":"/2023/11/04/c++-development-visual-studio-code-windows/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>주로 macOS에서 개발하는데 하필이면 렌더독이라고 그래픽관련 디버깅 도구가 윈도우에서 작동이 된다고 한다. 그래서 디버깅을 하기 위해 윈도우 개발 환경을 설정하기로 하는데!!!</p>\n<h2 id=\"전제-조건\"><a href=\"#전제-조건\" class=\"headerlink\" title=\"전제 조건\"></a>전제 조건</h2><ol>\n<li><a href=\"https://code.visualstudio.com/download\">비주얼 스튜디오 코드</a> 설치.</li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools\">VS Code용 C&#x2F;C++ 확장</a> 설치.</li>\n<li>Microsoft Visual C++(MSVC) 컴파일러 도구 세트를 설치.<ul>\n<li>해당 링크(<a href=\"https://visualstudio.microsoft.com/downloads/#remote-tools-for-visual-studio-2022)%EC%97%90%EC%84%9C\">https://visualstudio.microsoft.com/downloads/#remote-tools-for-visual-studio-2022)에서</a> Visual Studio 2022용 빌드 도구를 설치하면 된다.</li>\n<li>해당 프로그램에서 <code>C++를 사용한 데스크톱 개발</code> 설치</li>\n</ul>\n</li>\n<li>CMake 설치.<ul>\n<li>C++를 이용한 데스크톱 개발를 설치할 때 같이 설정이 되는데 만약 설정 해제하고 설치했다면 따로 설치하도록 한다.</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"프로젝트-생성\"><a href=\"#프로젝트-생성\" class=\"headerlink\" title=\"프로젝트 생성\"></a>프로젝트 생성</h2><p>샘플코드를 하나 만들어 준다.</p>\n<h3 id=\"main-cpp\"><a href=\"#main-cpp\" class=\"headerlink\" title=\"main.cpp\"></a>main.cpp</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"CMakeLists-txt\"><a href=\"#CMakeLists-txt\" class=\"headerlink\" title=\"CMakeLists.txt\"></a>CMakeLists.txt</h3><figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.0</span>)<br><br><span class=\"hljs-keyword\">project</span>(SampleCPlusPlusProject)<br><br><span class=\"hljs-keyword\">add_executable</span>(SampleCPlusPlusProject main.cpp)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"빌드\"><a href=\"#빌드\" class=\"headerlink\" title=\"빌드\"></a>빌드</h3><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">cmake -B ./build -G &quot;Visual Studio 16 2019&quot; .<br>cmake --build ./build --config Debug<br></code></pre></td></tr></table></figure>\n<p>해당 명령어를 사용하면 빌드를 할 수 있지만, Visual Studio Code를 사용하면 쉽게 할 수 있다.</p>\n<h2 id=\"vscode-폴더\"><a href=\"#vscode-폴더\" class=\"headerlink\" title=\"vscode 폴더\"></a>vscode 폴더</h2><p><code>.vscode</code> 폴더는 Visual Studio Code 프로젝트나 작업 공간에서 설정과 관련된 파일을 보관하는 디렉토리이다. 이 폴더는 특정 프로젝트 또는 작업에 대한 설정 및 환경 구성을 담당한다.</p>\n<ul>\n<li><code>tasks.json</code> (빌드 명령어 설정 파일): 이 파일은 프로젝트를 빌드하기 위한 명령어와 설정을 정의.</li>\n<li><code>launch.json</code> (디버깅 설정 파일) : 디버깅을 위한 설정을 담고 있으며, 디버거 설정과 실행 환경을 구성.</li>\n</ul>\n<p>생성된 파일들은 Visual Studio Code에서 C++ 개발 환경을 구성하고 프로젝트를 관리하는 데 도움을 준다.</p>\n<h3 id=\"tasks-json\"><a href=\"#tasks-json\" class=\"headerlink\" title=\"tasks.json\"></a>tasks.json</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br>    <span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;2.0.0&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;tasks&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>        <span class=\"hljs-punctuation\">&#123;</span><br>            <span class=\"hljs-attr\">&quot;label&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;cmake build and run&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 작업 이름</span><br>            <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;shell&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 명령어 실행을 위한 shell 타입</span><br>            <span class=\"hljs-attr\">&quot;command&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;cmake -B ./build -G &#x27;Visual Studio 16 2019&#x27; .; cmake --build ./build --config Debug; cd ./build/Debug; ./SampleCPlusPlusProject.exe&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 빌드 및 실행 커맨드 입력</span><br>            <span class=\"hljs-attr\">&quot;options&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;cwd&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;$&#123;workspaceFolder&#125;&quot;</span> <span class=\"hljs-comment\">// 현재 작업 디렉토리 설정</span><br>            <span class=\"hljs-punctuation\">&#125;</span><span class=\"hljs-punctuation\">,</span><br>            <span class=\"hljs-attr\">&quot;group&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">&#123;</span><br>                <span class=\"hljs-attr\">&quot;kind&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;build&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 작업 그룹을 빌드로 설정</span><br>                <span class=\"hljs-attr\">&quot;isDefault&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span> <span class=\"hljs-comment\">// 기본 작업으로 설정</span><br>            <span class=\"hljs-punctuation\">&#125;</span><br>        <span class=\"hljs-punctuation\">&#125;</span><br>    <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>ctrl + shift + b</code> 를 누르면 프로그램이 실행되는 것을 확인할 수 있다.</p>\n<h3 id=\"launch-json\"><a href=\"#launch-json\" class=\"headerlink\" title=\"launch.json\"></a>launch.json</h3><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-punctuation\">&#123;</span><br><span class=\"hljs-attr\">&quot;version&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;0.2.0&quot;</span><span class=\"hljs-punctuation\">,</span><br>    <span class=\"hljs-attr\">&quot;configurations&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><br>    <span class=\"hljs-punctuation\">&#123;</span><br>          <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;cmake build and debug&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 디버그 구성 이름</span><br>          <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;cppvsdbg&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// C++ 디버그 타입</span><br>          <span class=\"hljs-attr\">&quot;request&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;launch&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 디버그 실행 요청</span><br>          <span class=\"hljs-attr\">&quot;program&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;$&#123;workspaceFolder&#125;/build/Debug/SampleCPlusPlusProject.exe&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 실행할 바이너리 파일 경로</span><br>          <span class=\"hljs-attr\">&quot;args&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 실행 시 전달할 명령행 인수</span><br>          <span class=\"hljs-attr\">&quot;stopAtEntry&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 브레이크 포인트 사용 여부</span><br>          <span class=\"hljs-attr\">&quot;cwd&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;&quot;</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 현재 작업 디렉토리 (의존성 및 기타 파일을 찾기 위함)</span><br>          <span class=\"hljs-attr\">&quot;environment&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 환경 변수 설정</span><br>          <span class=\"hljs-attr\">&quot;externalConsole&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">true</span></span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-comment\">// 외부 콘솔 사용 여부</span><br>          <span class=\"hljs-attr\">&quot;preLaunchTask&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;cmake build and run&quot;</span> <span class=\"hljs-comment\">// 디버그 실행 전에 실행할 작업(Task) 이름</span><br>    <span class=\"hljs-punctuation\">&#125;</span><br>  <span class=\"hljs-punctuation\">]</span><br><span class=\"hljs-punctuation\">&#125;</span><br></code></pre></td></tr></table></figure>\n<p><code>F5</code>를 누르면 디버거가 실행되며 디버깅을 할 수 있게 된다.</p>\n<h2 id=\"Finish\"><a href=\"#Finish\" class=\"headerlink\" title=\"Finish\"></a>Finish</h2><p>이제 명령어를 안치고 간단한 단축키로 실행파일을 실행하고, 디버깅도 할 수 있다!!! 쉘 스크립트나 CMake를 이용해서 하나의 명령어로 OS별로 빌드, 실행, 디버깅되면 편하겠다. 이 부분에 대해서 좀 더 연구해봐야 할 듯!!!</p>\n<p>참고 링크</p>\n<ul>\n<li><a href=\"https://code.visualstudio.com/docs/cpp/config-msvc\">https://code.visualstudio.com/docs/cpp/config-msvc</a></li>\n<li><a href=\"https://developer0hye.tistory.com/299\">https://developer0hye.tistory.com/299</a></li>\n</ul>\n","categories":["C++"],"tags":["C++","Visual Studio Code","Setting up Development Environment","IDE","Code Editor","Development Tools","Windows OS","Windows Development"]},{"title":"그래픽스 관련 내용 통합 정리","url":"/2024/07/14/graphics-knowledge/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL:DR\"></a>TL:DR</h2><p>왜 중요한 순간에 기억이 나지 않는 것일까?<br>그래픽스 관련 내용을 한 페이지에서 해결 하기 위해 이글을 작성한다.</p>\n<h2 id=\"렌더링-파이프라인\"><a href=\"#렌더링-파이프라인\" class=\"headerlink\" title=\"렌더링 파이프라인\"></a>렌더링 파이프라인</h2><p>3차원으로 만들어진 모델을 2차원 화면에 투영하는 렌더링 과정.</p>\n<ol>\n<li><strong>Input Assembler(입력 조립기)</strong>: 정점 데이터와 인덱스 데이터를 수집하고 이를 조립하여 렌더링 파이프라인에 전달.</li>\n<li><strong>Vertex Shader(정점 셰이더)</strong>: 정점 배열에 저장된 모든 정점을 변환하고 다양한 연산을 수행. 주로 공간 변환(모델, 뷰, 투영 변환)과 라이팅 계산을 수행.</li>\n<li><strong>Tessellation(테셀레이션, 선택적)</strong>: 정점을 세밀하게 분할하여 더 많은 폴리곤을 생성, 부드러운 곡면을 표현할 때 사용.<ul>\n<li><strong>Tessellation Control Shader(테셀레이션 제어 셰이더)</strong>: 테셀레이션 레벨 결정.</li>\n<li><strong>Tessellation Evaluation Shader(테셀레이션 평가 셰이더)</strong>: 생성된 새로운 정점의 위치 계산.</li>\n</ul>\n</li>\n<li><strong>Geometry Shader(지오메트리 셰이더, 선택적)</strong>: 기본 도형(주로 삼각형)을 다른 도형으로 변환하거나 새로운 정점을 생성.</li>\n<li><strong>Rasterizer(래스터라이저)</strong>: 변환된 정점들로 삼각형을 조립하고 프래그먼트를 생성.</li>\n<li><strong>Clipping(클리핑)</strong>: 클립 공간의 정점들을 화면 공간으로 투영하기 전에 시야 범위 밖의 정점을 제거.</li>\n<li><strong>Fragment Shader(프래그먼트 셰이더)</strong>: 프래그먼트의 색상을 결정(라이팅, 텍스처링 등 진행).</li>\n<li><strong>Output Merger(출력 병합기)</strong>: 깊이, 스텐실, 블렌딩 테스트를 통해 최종 픽셀 색상을 결정하고 컬러 버퍼를 갱신.</li>\n<li><strong>Viewport Transform(뷰포트 변환)</strong>: 클립 공간에서 정점들을 화면 좌표로 변환.</li>\n<li><strong>Framebuffer(프레임버퍼)</strong>: 최종적으로 렌더링된 이미지가 저장되는 버퍼.</li>\n</ol>\n<p>정점 셰이더와 프래그먼트 셰이더는 두 가지 프로그램(셰이더 코드)을 작성해야 하며, 래스터라이저와 출력 병합기는 하드웨어로 고정된 단계로 정해진 연산을 수행한다.</p>\n<h3 id=\"공간-변환-순서\"><a href=\"#공간-변환-순서\" class=\"headerlink\" title=\"공간 변환 순서\"></a>공간 변환 순서</h3><p>오브젝트 공간 -(월드 변환)-&gt; 월드 공간 -(뷰 변환)-&gt; 카메라 공간 -(투영 변환)-&gt; 클립 공간.</p>\n<p>정점 셰이더가 수행하는 연산이 위에 적힌 공간 변환들입니다.</p>\n<h4 id=\"월드-변환\"><a href=\"#월드-변환\" class=\"headerlink\" title=\"월드 변환\"></a>월드 변환</h4><p>각 오브젝트 공간에서 만들어진 물체를 단일한 월드 공간으로 변환.</p>\n<h4 id=\"뷰-변환\"><a href=\"#뷰-변환\" class=\"headerlink\" title=\"뷰 변환\"></a>뷰 변환</h4><p>월드 공간의 특정 영역을 스크린에 렌더링하기 위해 가상 카메라의 위치와 방향을 설정.</p>\n<h4 id=\"투영-변환\"><a href=\"#투영-변환\" class=\"headerlink\" title=\"투영 변환\"></a>투영 변환</h4><p>카메라 기준의 정점 위치를 화면에 보이기 위한 정점 위치로 변환.</p>\n<h2 id=\"동차-좌표계\"><a href=\"#동차-좌표계\" class=\"headerlink\" title=\"동차 좌표계\"></a>동차 좌표계</h2><p>기하학적 변환을 보다 편리하게 수행하기 위해 사용되는 확장된 좌표계. 2D나 3D좌표를 고차원으로 확장하여 행렬 연산을 통해 다양한 기하학적 변환(이동, 회전, 스케일링, 원근 투영 등)을 일관되게 수행할 수 있음.</p>\n<h3 id=\"3차원-동차-좌표계\"><a href=\"#3차원-동차-좌표계\" class=\"headerlink\" title=\"3차원 동차 좌표계.\"></a>3차원 동차 좌표계.</h3><p>일반적인 3D 좌표 (x, y, z)를 동차 좌표계에서는 (x, y, z, w)로 표현합니다. 이때도 w는 스케일링 팩터로, 일반적으로 1로 설정. 일반 좌표 (x, y, z)는 (x&#x2F;w, y&#x2F;w, z&#x2F;w)로 변환할 수 있다.</p>\n<h3 id=\"4x4-행렬-사용-이유\"><a href=\"#4x4-행렬-사용-이유\" class=\"headerlink\" title=\"4x4 행렬 사용 이유\"></a>4x4 행렬 사용 이유</h3><ol>\n<li>일관된 기하학적 변환:<ul>\n<li>3D 공간에서의 모든 주요 기하학적 변환(이동, 회전, 스케일링, 원근 투영 등)을 하나의 행렬 연산으로 통합 할 수 있다.</li>\n<li>4x4 행렬을 사용하면 모든 변환을 하나의 행렬로 표현할 수 있어, 복잡한 변환을 단순한 행렬 곱셈으로 처리할 수 있다.</li>\n</ul>\n</li>\n<li>변환의 조합:</li>\n</ol>\n<ul>\n<li>여러 변환을 연속적으로 수행할 때, 각각의 변환을 개별적으로 수행하는 대신, 변환 행렬들을 곱해서 하나의 행렬로 결합할 수 있다.</li>\n<li>변환 행렬들의 곱은 순차적인 변환을 하나의 단일 행렬 연산으로 표현할 수 있게 한다.</li>\n</ul>\n<ol start=\"3\">\n<li>동차 좌표계의 표현:<ul>\n<li>동차 좌표계에서의 점 (x, y, z, w)을 4x4 행렬과 곱하여 새로운 점을 얻는다.</li>\n<li>이동 변환은 동차 좌표계에서 다음과 같이 표현:<br>  <img src=\"/../images/graphics-knowledge.md/image.webp\" alt=\"alt text\"></li>\n</ul>\n</li>\n<li>원근 투영 변환:<ul>\n<li><p>원근 투영 변환을 효과적으로 수행할 수 있다. 원근 투영 변환은 z-축을 기준으로 거리 비례 축소를 적용한다. 이는 동차 좌표계에서 다음과 같은 4x4 행렬로 표현된다.<br>  <img src=\"/../images/graphics-knowledge.md/image-1.webp\" alt=\"alt text\"></p>\n<p>  여기서 <code>d</code>는 원근 투영의 거리이다.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>동차 좌표계는 3D 기하학적 변환을 단순화하고, 여러 변환을 하나의 연산으로 통합할 수 있게 한다. 4x4 행렬을 사용함으로써, 다양한 변환을 효율적이고 일관되게 수행할 수 있으며, 특히 복잡한 변환을 쉽게 조합하고 적용할 수 있다.</p>\n<h2 id=\"벡터-활용\"><a href=\"#벡터-활용\" class=\"headerlink\" title=\"벡터 활용\"></a>벡터 활용</h2><h3 id=\"두-벡터-사이의-각도-구하기\"><a href=\"#두-벡터-사이의-각도-구하기\" class=\"headerlink\" title=\"두 벡터 사이의 각도 구하기\"></a>두 벡터 사이의 각도 구하기</h3><h4 id=\"내적으로-두-벡터의-사이각-구하기-0-180도\"><a href=\"#내적으로-두-벡터의-사이각-구하기-0-180도\" class=\"headerlink\" title=\"내적으로 두 벡터의 사이각 구하기 (0~180도)\"></a>내적으로 두 벡터의 사이각 구하기 (0~180도)</h4><p>두 벡터의 내적(dot product)을 두 벡터의 크기(magnitude)의 곱으로 나눈 후, 역코사인 함수를 사용하면 두 벡터 사이의 각도를 구할 수 있다.</p>\n<h4 id=\"내-외적으로-두-벡터의-사이각-구하기-0-360도\"><a href=\"#내-외적으로-두-벡터의-사이각-구하기-0-360도\" class=\"headerlink\" title=\"내&#x2F;외적으로 두 벡터의 사이각 구하기 (0 ~ 360도)\"></a>내&#x2F;외적으로 두 벡터의 사이각 구하기 (0 ~ 360도)</h4><p>두 벡터의 내적(dot product)을 두 벡터의 크기(magnitude)의 곱으로 나눈 값을 코사인 값으로 각도를 구하고, 외적(cross product)의 방향을 사용해 각도의 방향을 결정하여 0도에서 360도 사이의 각도를 구할 수 있다.</p>\n<h2 id=\"로컬-회전-구하는-법\"><a href=\"#로컬-회전-구하는-법\" class=\"headerlink\" title=\"로컬 회전 구하는 법.\"></a>로컬 회전 구하는 법.</h2><p>[추가 예정]</p>\n"},{"title":"Emscripten에서 파일 로딩하기","url":"/2024/04/20/loading-files-with-emscripten/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>폴더 안의 파일을 불러와서 사용하고 싶다.</p>\n<h2 id=\"Packaging-using-emcc\"><a href=\"#Packaging-using-emcc\" class=\"headerlink\" title=\"Packaging using emcc\"></a>Packaging using emcc</h2><p><a href=\"https://emscripten.org/docs/porting/files/packaging_files.html\">공식 페이지</a>에서는 컴파일 시 emcc 명령어를 사용하면 된다고 한다.</p>\n<p><code>--preload-file</code> 의 명령어를 사용하여 어떤 파일을 사용할지 설정해주면 된다.</p>\n<h2 id=\"CMakeList-txt에서-사용하기\"><a href=\"#CMakeList-txt에서-사용하기\" class=\"headerlink\" title=\"CMakeList.txt에서 사용하기.\"></a>CMakeList.txt에서 사용하기.</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">set_target_properties(app LINK_FLAGS &quot;--preload-file $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/ShaderFiles/EsShader@ShaderFiles&quot;)<br></code></pre></td></tr></table></figure>\n<p><code>@</code>를 통해 가상 파일 위치를 매핑할 수 있다. <code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/ShaderFiles/EsShader</code>의 위치를 <code>ShaderFiles</code>로 매핑했다.</p>\n<h2 id=\"파일-로드\"><a href=\"#파일-로드\" class=\"headerlink\" title=\"파일 로드.\"></a>파일 로드.</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">├── ShaderFiles<br>│   ├── EsShader<br>│   │   ├── basic_lighting.fs<br>│   │   └── basic_lighting.vs<br>│   ├── basic_lighting.fs<br>│   └── basic_lighting.vs<br></code></pre></td></tr></table></figure>\n<p>파일 트리는 다음과 같다. <code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/ShaderFiles/EsShader</code>의 위치를 <code>ShaderFiles</code> 로 매핑했기 때문에 플랫폼에 따라 경로를 변경하지 않아도 된다.</p>\n","tags":["emscripten","wasm","c++"]},{"title":"GLM 행렬(mat) 또는 벡터(vec) 출력하기","url":"/2023/10/19/Print-a-GLM-mat-or-vec/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>glm의 계산 결과를 확인하기 위해서 출력해야하는 경우가 있다. 이럴 때는 <code>glm/gtx/string_cast.hpp</code>을 인클루드 하고 <code>glm::to_string</code> 함수를 호출하면 된다.</p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"></a>Code</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/gtx/string_cast.hpp&gt;</span></span><br><br>glm::mat4 mat;<br>std::cout &lt;&lt; glm::<span class=\"hljs-built_in\">to_string</span>(mat) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><h3 id=\"벡터-출력\"><a href=\"#벡터-출력\" class=\"headerlink\" title=\"벡터 출력\"></a>벡터 출력</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">glm::vec3 <span class=\"hljs-title\">vector1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3.0f</span>)</span></span>;<br><span class=\"hljs-function\">glm::vec3 <span class=\"hljs-title\">vector2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4.0f</span>, <span class=\"hljs-number\">5.0f</span>, <span class=\"hljs-number\">6.0f</span>)</span></span>;<br>    <br>glm::vec3 result_vec = vector1 + vector2;<br>    <br>std::cout &lt;&lt; glm::<span class=\"hljs-built_in\">to_string</span>(result_vec) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"결과\"><a href=\"#결과\" class=\"headerlink\" title=\"결과\"></a>결과</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">vec3(5.000000, 7.000000, 9.000000)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"행렬-출력\"><a href=\"#행렬-출력\" class=\"headerlink\" title=\"행렬 출력\"></a>행렬 출력</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">glm::mat4 result_mat = glm::<span class=\"hljs-built_in\">translate</span>(glm::<span class=\"hljs-built_in\">mat4</span>(<span class=\"hljs-number\">1.0f</span>), glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">3.0f</span>));<br>std::cout &lt;&lt; glm::<span class=\"hljs-built_in\">to_string</span>(result_mat) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>\n<h4 id=\"결과-1\"><a href=\"#결과-1\" class=\"headerlink\" title=\"결과\"></a>결과</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">mat4x4((<span class=\"hljs-number\">1.000000</span>, <span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">0.000000</span>), (<span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">1.000000</span>, <span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">0.000000</span>), (<span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">0.000000</span>, <span class=\"hljs-number\">1.000000</span>, <span class=\"hljs-number\">0.000000</span>), (<span class=\"hljs-number\">1.000000</span>, <span class=\"hljs-number\">2.000000</span>, <span class=\"hljs-number\">3.000000</span>, <span class=\"hljs-number\">1.000000</span>))<br></code></pre></td></tr></table></figure>\n<p>정리하면 다음과 같다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">(1.000000, 0.000000, 0.000000, 0.000000)<br>(0.000000, 1.000000, 0.000000, 0.000000)<br>(0.000000, 0.000000, 1.000000, 0.000000)<br>(1.000000, 2.000000, 3.000000, 1.000000)<br></code></pre></td></tr></table></figure>\n\n<p><code>glm</code>은 열중심으로 출력되어 있는 것을 확인할 수 있다.</p>\n<h2 id=\"여담\"><a href=\"#여담\" class=\"headerlink\" title=\"여담\"></a>여담</h2><ul>\n<li><p>전체 소스코드는 <a href=\"https://gist.github.com/keea/0f4fea0d2f00e3114e8424b7bddb3fe4\">https://gist.github.com/keea/0f4fea0d2f00e3114e8424b7bddb3fe4</a> 에서 확인 하실 수 있습니다.</p>\n</li>\n<li><p>reference : <a href=\"https://gist.github.com/donaldmunro/38841d72c65a1c32f2bf83a4a00a2c9a\">https://gist.github.com/donaldmunro/38841d72c65a1c32f2bf83a4a00a2c9a</a></p>\n</li>\n</ul>\n","categories":["Graphics"],"tags":["graphic","opengl","glm","math"]},{"title":"RenderDoc 사용 방법","url":"/2024/02/06/how-to-use-renderdoc/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>OpenGL을 사용하여 작업하는데 렌더링이 제대로 되지 않는 경우가 빈번해서 꽤나 골치아팠다. 이럴 때 디버깅을 할 수 있는 도구가 있을까 찾아보다가 렌더독(RenderDoc)을 알게 되었다! 렌더독을 사용하면서 많은 문제들을 해결할 수 있게 되었다. 지금은 렌더독을 사용하는 방법에 대해 정리해보고자 한다.</p>\n<h2 id=\"설치\"><a href=\"#설치\" class=\"headerlink\" title=\"설치\"></a>설치</h2><p><a href=\"https://renderdoc.org/builds\">https://renderdoc.org/builds</a> 에서 파일을 다운 받아 설치</p>\n<h2 id=\"Capturing-a-frame\"><a href=\"#Capturing-a-frame\" class=\"headerlink\" title=\"Capturing a frame\"></a>Capturing a frame</h2><p><code>File</code> -&gt; <code>Launch Application</code><br><img src=\"/images/how-to-use-renderdoc.md/image.webp\" alt=\"Alt text\"></p>\n<h3 id=\"Program-Setting\"><a href=\"#Program-Setting\" class=\"headerlink\" title=\"Program Setting\"></a><code>Program</code> Setting</h3><ul>\n<li><code>Excutable Path</code>  :  캡쳐할 어플리케이션의 실행 파일 경로를 선택. 캡쳐하려는 프로그램이 어디에 설치되어 있는지 정확히 지정해야한다.</li>\n<li><code>Working Directory</code> : 어플리케이션을 실행할 때 필요한 작업 디렉토리를 설정. 어플리케이션이 관련된 파일을 찾을 수 있도록 정확한 디렉토리를 지정해야 한다.</li>\n<li><code>Command-line Arguments</code> : 어플리케이션을 실행할 때 필요한 커맨드 라인 인자를 설정.</li>\n</ul>\n<p><code>Launch</code> 버튼으로 실행.</p>\n<h2 id=\"프레임-캡처\"><a href=\"#프레임-캡처\" class=\"headerlink\" title=\"프레임 캡처\"></a>프레임 캡처</h2><p>RenderDoc이 성공적으로 로드외어 프레임을 캡쳐할 준비가 되었음을 나타내기 위한 최소한의 인앱 오버레이가 존재.<br>준비가 되면 <code>F12</code> 또는 <code>PrintScreen</code>를 누르면 다음 프레임이 캡쳐되며 이는 오버레이에 표시되어 프레임이 성공적으로 저장되었음을 알려줌.<br><img src=\"/images/how-to-use-renderdoc.md/image-1.webp\" alt=\"Alt text\"><br>어플리케이션이 종료될 때 프레임을 캡처한 경우 자동으로 RenderDoc UI에서 열리기 시작함.</p>\n<h2 id=\"그래픽-파이프라인-검사\"><a href=\"#그래픽-파이프라인-검사\" class=\"headerlink\" title=\"그래픽 파이프라인 검사\"></a>그래픽 파이프라인 검사</h2><p>파이프라인 뷰어는 그래픽 파이프라인의 모든 상태 설정을 보여주며, 바인딩 된 리소스, 래스터라이저 설정 등을 포함한다.<br><code>Window</code> -&gt; <code>Pipeline State</code><br><img src=\"/images/how-to-use-renderdoc.md/image-2.webp\" alt=\"Alt text\"></p>\n<h3 id=\"파이프라인-흐름도\"><a href=\"#파이프라인-흐름도\" class=\"headerlink\" title=\"파이프라인 흐름도\"></a>파이프라인 흐름도</h3><p>파이프라인 뷰어 상단에 파이프라인 흐름도가 존재.<br>그래픽 파이프라인의 고수준 블록 레벨 다이어그램을 보여줌.<br><img src=\"/images/how-to-use-renderdoc.md/image_1706152588023_0.webp\" alt=\"Alt text\"></p>\n<ul>\n<li>빨간색 : 선택한 블록.</li>\n<li>연한 회색 : 현재 활성화되어 이 작업에 참여하는 부분.</li>\n<li>어두운 회색 : 비활성화되어 패스스루 &#x2F; 아무 동작도 수행하지 않음.</li>\n</ul>\n<h2 id=\"버퍼-검사\"><a href=\"#버퍼-검사\" class=\"headerlink\" title=\"버퍼 검사\"></a>버퍼 검사</h2><p>파이프라인 단계(<code>VTX(Vertex Input)</code>, <code>VS</code>, <code>FS</code>) 에서 버퍼를 확인할 수 있다.<br><img src=\"/images/how-to-use-renderdoc.md/image-3.webp\" alt=\"Alt text\"></p>\n<ul>\n<li><code>glDrawElements</code> 이벤트의 <code>VTX (Vertex Input)</code>단계의 버퍼 확인.</li>\n</ul>\n<p>이동 아이콘을 누르면 더 자세한 보기가 가능하다.<br><img src=\"/images/how-to-use-renderdoc.md/image-4.webp\" alt=\"Alt text\"></p>\n<ul>\n<li>자세한 보기를 누른 상태.</li>\n<li><code>vertex.aPos</code>의 값을 확인할 수 있다.</li>\n</ul>\n<h2 id=\"텍스처-검사\"><a href=\"#텍스처-검사\" class=\"headerlink\" title=\"텍스처 검사\"></a>텍스처 검사</h2><p>텍스처 뷰어는 어플리케이션에서 텍스처를 검사하고 대상을 렌더링 할 수 있다.<br>다양한 시각화 컨트롤이 있어 여러 채널, 밉 레벨 등을 볼 수 있다.<br><img src=\"/images/how-to-use-renderdoc.md/image-5.webp\" alt=\"Alt text\"></p>\n<h2 id=\"사용-예시\"><a href=\"#사용-예시\" class=\"headerlink\" title=\"사용 예시\"></a>사용 예시</h2><h3 id=\"VertexShader-Input-값과-Output-값을-확인-Opengl\"><a href=\"#VertexShader-Input-값과-Output-값을-확인-Opengl\" class=\"headerlink\" title=\"VertexShader Input 값과 Output 값을 확인(Opengl)\"></a>VertexShader Input 값과 Output 값을 확인(Opengl)</h3><ol>\n<li><code>Event Browser</code>에서 <code>glDrawElements</code> 이벤트 선택.</li>\n<li><code>Pipeline State</code>에서 <code>VTX(Vertex Input)</code> 단계 <code>Vertex Attribute Format</code>을 아무거나 <code>Go</code>(초록색 화살표 클릭).<br><img src=\"/images/how-to-use-renderdoc.md/image-6.webp\" alt=\"Alt text\"></li>\n<li><code>Mesh Viewer</code> 창이 뜨며 <code>VS Input</code>에서 입력 값과 <code>VS Output</code>에서 버택스 셰이더의 아웃풋 값을 확인할 수 있다.<br><img src=\"/images/how-to-use-renderdoc.md/image-7.webp\" alt=\"Alt text\"></li>\n</ol>\n<p>Preview에서 메시를 확인할 수 있다.</p>\n<ul>\n<li><p><code>VS In</code>의 메시.<br><img src=\"/images/how-to-use-renderdoc.md/image-8.webp\" alt=\"Alt text\"></p>\n</li>\n<li><p><code>VS Out</code>의 메시.<br><img src=\"/images/how-to-use-renderdoc.md/image-9.webp\" alt=\"Alt text\"></p>\n</li>\n</ul>\n","tags":["Development Tools","RenderDoc","Graphics Debugging","Rendering"]},{"title":"HackMD 글을 Hugo 형태로 변경","url":"/2023/01/27/hackmd-to-hugo/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>HackMD라는 마크다운 에디터를 찾았다. 에디터도 마음에 들지만 깃허브로 푸시하여 문서들을 관리할 수 있다. 그렇다면 해당 문서들을 정적 블로그의 포스트로 사용하는 것이 좋다고 생각했고 이 부분을 자동화하고자 했다.</p>\n<p>그래서 현재 HackMD에서 작성한 문서를 레파지토리에 푸시하면 hugo 포스트 형식으로 변환하여 hugo 홈페이지에 적용했다.</p>\n<h2 id=\"date-추가하기\"><a href=\"#date-추가하기\" class=\"headerlink\" title=\"date 추가하기\"></a>date 추가하기</h2><p>최초 레파지토리에 푸시할 때 자동적으로 <code>date</code>를 추가했다. 이것은 아래와 같이 진행했다.</p>\n<p>이 부분은 <a href=\"https://fatihkalifa.com/twitter-github-actions\">https://fatihkalifa.com/twitter-github-actions</a> 해당 글을 참고하여 작업했다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">git diff --name-status HEAD~1 | grep &quot;.md$&quot; | grep &quot;^A&quot; | cut -c 3-<br></code></pre></td></tr></table></figure>\n<p><code>git diff</code> 명령어를 사용하면 파일의 어떤 내용이 변경되는지 알 수 있다. <code>HEAD~1</code>로 가장 최신의 변경 사항을 가져온다. </p>\n<ul>\n<li><p><code>git diff --name-status HEAD~1</code> 다음과 같은 결과를 얻을 수 있다.</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">M       test34567.md<br>A       test555.md<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>여기서 원하는 것은 새로 추가된 <code>test555.md</code>이다. 그래서 <code>grep</code>과 <code>cut</code> 명령어를 통해 원하는 것을 파싱을 했다.</p>\n<ul>\n<li><code>grep &quot;.md$&quot;</code> : md 파일 찾는다.</li>\n<li><code>grep &quot;^A&quot;</code> : A로 시작한 것을 찾는다. git diff로 확인하면 맨 처음에 A(Add), M(Modify) 등으로 표시한다.</li>\n<li><code>cut -c 3-</code> : 불필요한 명령어들을 삭제해버린다.</li>\n</ul>\n<p>위의 명령어를 실행 시 다음과 같은 결과를 얻었다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">test555.md<br></code></pre></td></tr></table></figure>\n<p>새로 추가된 마크다운 문서의 파일명을 구했으니 <code>date</code>를 추가하면 된다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">sed -i &quot;/^date:/s/.*/date: `date &quot;+%Y-%m-%d %H:%M:%S&quot;`/g&quot; test555.md<br></code></pre></td></tr></table></figure>\n<p><code>sed</code> 명령어를 통해 파일의 내용을 변경하도록 했다. <code>date:</code> 라는 부분을 찾아 <code>date: &#123;현재날짜&#125;</code>로 변경한다. 이걸 하기 위해서는 해당 문서 안에 <code>date:</code> 부분이 있어야한다. </p>\n<p>뭐 이 정도는 HackMD의 템플릿 기능을 사용해 자동으로 추가했다.</p>\n<p>현재 날짜는 <code>date</code>명령어를 통해 구했다. <code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 를 사용하여 hugo 형식인 “년-월-일 시간” 포맷을 취할 수 있다.</p>\n<p>그 후 변경된 내용을 커밋하면 되는 것이다!!</p>\n<h2 id=\"hugo-형태의-파일-트리-만들기\"><a href=\"#hugo-형태의-파일-트리-만들기\" class=\"headerlink\" title=\"hugo 형태의 파일 트리 만들기\"></a>hugo 형태의 파일 트리 만들기</h2><p>이제 날짜를 추가했으니 hugo 홈페이지에 보일 수 있게 파일 구조도 신경써야한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">./content<br>|____posts<br>| |____start<br>| | |____feature.jpg<br>| | |____index.md<br></code></pre></td></tr></table></figure>\n<p>내가 사용하는 템플릿 콘텐츠 파일 구조에는 블로그 포스트들을 저장하는 <code>posts</code>라는 폴더가 있으며 각 포스트별로 제목(ex:<code>start</code>) 폴더 안에 실제 포스트인 <code>index.md</code>와 썸네일인 <code>feature.jpg</code>로 구성되어 있다.</p>\n<p>마크다운 파일 이름을 구해 폴더를 만들고 해당 마크다운의 이름을 index.md로 만들면 된다고 생각했다.<br>파일명은 위에서 같이 구하면 되고 이름은 <code>basename</code> 이라는 명령어를 사용하면 구할 수가 있다고 해서 바로 시작했다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">title=$(basename $&#123;&#123; steps.push-file.outputs.file &#125;&#125; .md)<br></code></pre></td></tr></table></figure>\n<p><code>basename</code>으로 파일명을 구하고 <code>.md</code>명령어로 확장자를 제거해버렸다. 어차피 위에서 md파일만 구하기 때문에 상관 없었다.</p>\n<p>이름 변경하는 것이나 파일 위치 변경하는 것은 <code>mv</code> 명령어를 사용하면 된다.</p>\n<p>이후 나는 <code>hugo</code>라는 브런치를 만들어서 따로 관리하고 싶었다. <code>hugo</code> 같은 경우도 빌드한 후 빌드의 산출물을 다른 브런치에다가 다 저장하는 것이다. 나도 이걸 하고 싶었다!!</p>\n<p>대충 생각한 플로우는 다음과 같다.</p>\n<ol start=\"0\">\n<li>hugo 사이트에서 <code>content/post</code>에 hackmd 저장소를 서브모듈로 등록.</li>\n<li>hackmd에서 문서 작성 후 푸시.</li>\n<li>hackmd 저장한 레파지토리에서 hugo 형식에 맞게 변경.</li>\n<li>변경 후 hugo 레파지토리도 같이 업데이트.</li>\n</ol>\n<h3 id=\"브런치-작업\"><a href=\"#브런치-작업\" class=\"headerlink\" title=\"브런치 작업\"></a>브런치 작업</h3><p>우선 빈 브런치부터 만들었다. 이런 것을 고아브런치라고 하는 것을 알았다. <a href=\"https://blog.naver.com/writer0713/221611414098\">https://blog.naver.com/writer0713/221611414098</a> 글을 참고해서 <code>hugo-content</code> 고아 브런치를 만들었다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">git checkout --orphan hugo-content<br>git rm -rf .<br>git commit --allow-empty -m &quot;init hugo content&quot;<br>git push origin hugo-content<br></code></pre></td></tr></table></figure>\n\n<p>그 후 위에 작업한 것을 커밋을 하기 위해 새로운 폴더를 만들고 github action 안에서 커밋을 했지만 맘에 들지 않았다. <code>content/post/start</code> 로 되어있는 것보다 <code>post</code> 폴더 안에 있는 내용물만 푸시하고 싶기 때문이다. 그래서 <code>peaceiris/actions-gh-pages@v3</code> 소스코드를 까봤다.</p>\n<p>여기서 해결하는 방법은 푸시하고 싶은 내용물이 든 폴더에 <code>.git</code> 폴더를 복사해 넣고 커밋한 후 푸시하는 것이다!! 나는 해당 폴더에 <code>git init</code>로 초기화 해 다시 다 설정해야하나 생각했는데 <code>.git</code>폴더를 복사하면 설정을 다시 안해도 되기 때문에 좋다!!</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">mkdir -p $&#123;dir&#125;/$&#123;content&#125;/$&#123;title&#125;<br>cp -r $&#123;dir&#125;/.git $&#123;dir&#125;/$&#123;content&#125;<br>cd $&#123;dir&#125;/$&#123;content&#125;<br>git fetch origin<br>git checkout hugo-content<br>mv $&#123;&#123; steps.push-file.outputs.file &#125;&#125; $&#123;dir&#125;/$&#123;content&#125;/$&#123;title&#125;/$&#123;filename&#125;<br>git add --all<br>git config --global user.email $&#123;&#123; secrets.EMAIL &#125;&#125;<br>git config --global user.name $&#123;&#123; secrets.USER_NAME &#125;&#125;<br>git commit -am &quot;[POST] Add Hugo Post&quot;<br>git push origin hugo-content<br></code></pre></td></tr></table></figure>\n<p>폴더 만들고 <code>.git</code>파일 복사하고 커밋할 파일 옮기고 커밋하고 푸시하는 것까지 완료했다. 이제 <code>hugo-content</code> 브런치에는 hugo 형태의 포스터 파일만 남아있게 되었다!!</p>\n<h2 id=\"썸네일-추가하기\"><a href=\"#썸네일-추가하기\" class=\"headerlink\" title=\"썸네일 추가하기\"></a>썸네일 추가하기</h2><p>간지나게 썸네일도 추가하고 싶었다. 썸네일이 없으니 심심해서 추가하고 싶었다. 근데 썸네일을 찾아서 추가하고 싶지는 않았다. 자동으로 그리는 프로그램을 만들어야 하나??? 아니면 좀 더 빠르게 할 수 있는 방법이 있지 않나 생각보다가 NASA에서 매일마다 우주 사진을 업로드를 해준다는 것이 생각났다.</p>\n<p>Astronomy Picture of the Day(<a href=\"https://apod.nasa.gov/apod/astropix.html\">https://apod.nasa.gov/apod/astropix.html</a>) 일명 APOD로 우주 사진과 우주에 대한 설명을 해준다. 썸네일로도 괜찮은 것 같고 블로그 스킨에도 잘 어울렸다.</p>\n<p>‘아 이걸 사용하면 되겠다’ 생각하며 좀 더 API(<a href=\"https://api.nasa.gov/)%EB%8F%84\">https://api.nasa.gov/)도</a> 제공해준다는 것이다. 이런 것은 빠르게 작성할 수 있는 Python을 이용해서 만들어보았다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fetch_apod</span>(<span class=\"hljs-params\">date</span>):<br>    apod_url = <span class=\"hljs-string\">&quot;https://api.nasa.gov/planetary/apod&quot;</span><br>    params = &#123;<br>        <span class=\"hljs-string\">&#x27;api_key&#x27;</span>:os.environ.get(<span class=\"hljs-string\">&#x27;APOD_API_KEY&#x27;</span>),<br>        <span class=\"hljs-string\">&#x27;date&#x27;</span>:date,<br>        <span class=\"hljs-string\">&#x27;hd&#x27;</span>:<span class=\"hljs-string\">&#x27;True&#x27;</span><br>    &#125;<br>    response = requests.get(apod_url, params=params, timeout=<span class=\"hljs-number\">5</span>).json()<br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&quot;hdurl&quot;</span>]<br></code></pre></td></tr></table></figure>\n\n<p>api를 요청하여 이미지 주소를 가져온다. git action 환경변수로 api키를 등록하기 때문에 <code>os.environ.get(&#39;APOD_API_KEY&#39;)</code>를 사용했다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">random_date</span>():<br>    start_date = datetime.today().replace(day=<span class=\"hljs-number\">1</span>, month=<span class=\"hljs-number\">1</span>, year=<span class=\"hljs-number\">2015</span>).toordinal()<br>    end_date = datetime.today().toordinal()<br>    <span class=\"hljs-keyword\">return</span> datetime.fromordinal(random.randint(start_date, end_date)).strftime(<span class=\"hljs-string\">&quot;%Y-%m-%d&quot;</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_image</span>(<span class=\"hljs-params\">url, file_path</span>):<br>    os.system(<span class=\"hljs-string\">&quot;curl &quot;</span> + url + <span class=\"hljs-string\">&quot; &gt; &quot;</span> + file_path)<br></code></pre></td></tr></table></figure>\n\n<p>날짜는 2015년 1월 1일 부터 현재까지의 날짜를 받기로 했다. 같은 날 같은 썸네일은 좀 그래서 랜덤으로 했다. 이미지 다운로드는 그냥 <code>curl</code>명령어를 호출 하는 형태로 했다.</p>\n<p>git action에서는 다음과 같이 호출하면 된다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">python3 ../apod/apod.py $&#123;dir&#125;/$&#123;content&#125;/$&#123;title&#125;/feature.jpg<br></code></pre></td></tr></table></figure>\n<p><code>apod.py</code>로 실행하고 인자값은 저장할 파일 경로로 했다. 당연히 인자 값을 넣기 때문에 python에서 해당 부분을 처리를 해주도록 했다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">file_path = &quot; &quot;.join(sys.argv[1:len(sys.argv)])<br></code></pre></td></tr></table></figure>\n<p>풀 소스코드는 다음과 같다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-string\">&quot;&quot;&quot;Module providingFunction printing python version.&quot;&quot;&quot;</span><br><span class=\"hljs-keyword\">import</span> random<br><span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime<br><span class=\"hljs-keyword\">import</span> os<br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> sys<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">random_date</span>():<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    &quot;random&quot; to get one date from 2015-01-01 to today</span><br><span class=\"hljs-string\">    Returns:</span><br><span class=\"hljs-string\">        date(str)</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    start_date = datetime.today().replace(day=<span class=\"hljs-number\">1</span>, month=<span class=\"hljs-number\">1</span>, year=<span class=\"hljs-number\">2015</span>).toordinal()<br>    end_date = datetime.today().toordinal()<br>    <span class=\"hljs-keyword\">return</span> datetime.fromordinal(random.randint(start_date, end_date)).strftime(<span class=\"hljs-string\">&quot;%Y-%m-%d&quot;</span>)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_image</span>(<span class=\"hljs-params\">url, file_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    Image Download</span><br><span class=\"hljs-string\">        Args:</span><br><span class=\"hljs-string\">            url(str): image url</span><br><span class=\"hljs-string\">            file_path(str): path to save</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    os.system(<span class=\"hljs-string\">&quot;curl &quot;</span> + url + <span class=\"hljs-string\">&quot; &gt; &quot;</span> + file_path)<br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fetch_apod</span>(<span class=\"hljs-params\">date</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    Call APOD API</span><br><span class=\"hljs-string\">        Args:</span><br><span class=\"hljs-string\">            date(str) : date</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    apod_url = <span class=\"hljs-string\">&quot;https://api.nasa.gov/planetary/apod&quot;</span><br>    params = &#123;<br>        <span class=\"hljs-string\">&#x27;api_key&#x27;</span>:os.environ.get(<span class=\"hljs-string\">&#x27;APOD_API_KEY&#x27;</span>),<br>        <span class=\"hljs-string\">&#x27;date&#x27;</span>:date,<br>        <span class=\"hljs-string\">&#x27;hd&#x27;</span>:<span class=\"hljs-string\">&#x27;True&#x27;</span><br>    &#125;<br>    response = requests.get(apod_url, params=params, timeout=<span class=\"hljs-number\">5</span>).json()<br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&quot;hdurl&quot;</span>]<br><br><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>():<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    Main function</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    file_path = <span class=\"hljs-string\">&quot; &quot;</span>.join(sys.argv[<span class=\"hljs-number\">1</span>:<span class=\"hljs-built_in\">len</span>(sys.argv)])<br>    hdurl = fetch_apod(random_date())<br>    download_image(hdurl, file_path)<br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"서브모듈-업데이트\"><a href=\"#서브모듈-업데이트\" class=\"headerlink\" title=\"서브모듈 업데이트\"></a>서브모듈 업데이트</h2><p>이제 푸시되면 hugo사이트에서 자동으로 업데이트를 하게하면 글쓰는 것 외에 아무것도 신경 안써도 된다!!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yml\"><span class=\"hljs-attr\">Update:</span><br>  <span class=\"hljs-attr\">needs:</span> <span class=\"hljs-string\">hugo-format-setting</span><br>  <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span><br>  <span class=\"hljs-attr\">steps:</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span><br>      <span class=\"hljs-attr\">with:</span><br>        <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">github.repository_owner</span> <span class=\"hljs-string\">&#125;&#125;/keea.github.io</span><br>        <span class=\"hljs-attr\">token:</span> <span class=\"hljs-string\">$&#123;&#123;</span> <span class=\"hljs-string\">secrets.PRIVATE_TOKEN_GITHUB</span> <span class=\"hljs-string\">&#125;&#125;</span><br>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Pull</span> <span class=\"hljs-string\">&amp;</span> <span class=\"hljs-string\">update</span> <span class=\"hljs-string\">submodules</span> <span class=\"hljs-string\">recursively</span><br>      <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">        git submodule update --init --recursive</span><br><span class=\"hljs-string\">        git submodule update --recursive --remote</span><br><span class=\"hljs-string\"></span>    <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Commit</span><br>      <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|</span><br><span class=\"hljs-string\">        git config user.email $&#123;&#123; secrets.EMAIL &#125;&#125;</span><br><span class=\"hljs-string\">        git config user.name $&#123;&#123; secrets.USER_NAME &#125;&#125;</span><br><span class=\"hljs-string\">        git add --all</span><br><span class=\"hljs-string\">        git commit -m &quot;📝 Update Post&quot; || echo &quot;No changes to commit&quot;</span><br><span class=\"hljs-string\">        git push</span><br></code></pre></td></tr></table></figure>\n<p>hugo 포맷 설정하는 것이 끝나면 hugo 사이트의 레파지토리를 체크아웃해서 서브모듈 업데이트하고 푸시하면 된다. 아쉽게도 템플릿도 서브모듈로 등록되었기 때문에 같이 업데이트 해줄 것이다.<br><code>PRIVATE_TOKEN_GITHUB</code>은 <a href=\"https://github.com/settings/tokens\">https://github.com/settings/tokens</a> 에서 토큰 만들고 <code>Repository secrets</code> 에 등록하면 된다.</p>\n<h2 id=\"마지막으로\"><a href=\"#마지막으로\" class=\"headerlink\" title=\"마지막으로..\"></a>마지막으로..</h2><p>이렇게 HackMD에서 작성한 글을 자동으로 hugo 사이트의 포스트로 만들도록 했다. 생각보다 github action 다루는 것이 어려워 엄청 많은 시도를 했다. 물론 테스트 레파지토리에서… 아직 몇 가지 더 많이 남았지만 우선 이 정도로 마무리 짓고 더 업그레이드 할 것이다.</p>\n<p>예를 들어 gist 포맷을 자동으로 바꿔준다던가… 등등</p>\n<p>사실 글을 쓰고 날짜 맞춰서 추가해주고 폴더도 만들어서 추가해주는 것이 이걸 만드는 것보다 시간 소모가 덜 될 수도 있다고 생각이 들기는 하지만 이런 것도 신경써야하기 때문에 그냥 자동화 해버렸다.</p>\n<p>이제 글 쓰는 것에 집중해야겠다!!!</p>\n","categories":["blog"],"tags":["blog"]},{"title":"메모리 문제 해결하기","url":"/2024/02/23/management-with-circular-queue/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>Web에서 웹캠 프레임 데이터를 받아 처리를 하는 프로그램을 만들고 있다. 근데 시간이 지나면 메모리 문제가 발생한다. 이를 해결하기 위해 여러 방법을 시도하게 되는데!</p>\n<h2 id=\"현재-상황과-문제점\"><a href=\"#현재-상황과-문제점\" class=\"headerlink\" title=\"현재 상황과 문제점\"></a>현재 상황과 문제점</h2><p>프로세스는 웹캠 프레임 데이터를 처리하기 위해 큐를 활용하고 있다. 그러나 매번 새로운 데이터가 추가될 때마다 메모리를 할당하고 큐에 저장한 후, 데이터를 처리한 후에 해당 데이터의 메모리를 해제해야 하는 과정에서 문제가 발생하고 있다. 이 과정에서 메모리 할당이 해제보다 빠르게 진행되어 메모리 사용량이 지나치게 늘어나는 현상이 나타나고 있다. 이로 인해 큐에 저장되는 데이터의 양이 해제되는 데이터의 양보다 많아지는 문제가 발생하고 있다.</p>\n<p><img src=\"/images/management-with-circular-queue.md/image.webp\" alt=\"alt text\"></p>\n<p>현재 설정된 최대 메모리 한계는 약 2GB이지만, 실제 데이터가 저장되는 양은 이를 초과한다. 예를 들어, 각 데이터가 800(width) * 600(height) * 4(rgba) 바이트 크기로 저장되고 이러한 데이터가 1729개 저장된다면 전체 메모리 사용량은 3.18GB에 이를 것이다.</p>\n<h2 id=\"해결-방안\"><a href=\"#해결-방안\" class=\"headerlink\" title=\"해결 방안\"></a>해결 방안</h2><p>이 문제를 해결하기 위해 매번 새로운 데이터가 추가될 때마다 메모리를 할당하는 것보다는 미리 몇 개의 메모리를 할당하고 재사용하는 방법을 추천 받았다. 이를 위해 원형 큐를 변형하여 사용하기로 결정했다.</p>\n<p>원형 큐를 선택한 이유는 미리 몇 개의 메모리를 할당하여 재사용할 수 있으며, 큐가 가득 찬 경우 가장 오래된 데이터를 제거하고 새로운 데이터를 추가할 수 있기 때문이다. 이러한 방식은 웹캠 프레임 데이터의 손실이 허용되었기 때문에 가능했다.</p>\n<p>해야할 조치는 다음과 같다.</p>\n<ol>\n<li>매번 데이터를 저장할 때마다 새로운 메모리를 할당하는 것이 아니라, 몇 개의 메모리를 미리 할당하여 재사용해야한다.</li>\n<li>큐에 데이터가 가득 찬 경우, 가장 오래된 데이터를 제거하고 새로운 데이터를 추가해야 한다. 이를 통해 큐의 크기를 일정하게 유지할 수 있다.</li>\n</ol>\n<h2 id=\"원형-큐-활용하기\"><a href=\"#원형-큐-활용하기\" class=\"headerlink\" title=\"원형 큐 활용하기\"></a>원형 큐 활용하기</h2><p>위의 문제를 해결하기 위해 원형 큐를 활용하여 구현했다. </p>\n<h3 id=\"원형-큐의-생성\"><a href=\"#원형-큐의-생성\" class=\"headerlink\" title=\"원형 큐의 생성\"></a>원형 큐의 생성</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">CircularQueue</span>(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> buffer_size) : <span class=\"hljs-built_in\">head_</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">tail_</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">size_</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">buffer_size_</span>(buffer_size) &#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; MAX_BUFFER_SIZE; i++) &#123;<br>        data_.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>[buffer_size]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>원하는 버퍼 사이즈만큼 추가하여 원형 큐를 생성한다. 이때, <code>head</code>는 나중에 데이터를 가져올 때의 인덱스를, <code>tail</code>은 데이터를 추가할 위치를 나타낸다.</p>\n<h3 id=\"데이터-추가\"><a href=\"#데이터-추가\" class=\"headerlink\" title=\"데이터 추가\"></a>데이터 추가</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Enqueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>* value)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (size_ &lt; MAX_BUFFER_SIZE) &#123;<br>        size_++;<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        head_ = (head_ + <span class=\"hljs-number\">1</span>) % MAX_BUFFER_SIZE;<br>    &#125;<br><br>    std::<span class=\"hljs-built_in\">memcpy</span>(data_[tail_], value, buffer_size_);<br>    tail_ = (tail_ + <span class=\"hljs-number\">1</span>) % MAX_BUFFER_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>데이터를 추가할 때, 큐의 크기를 넘어서는 경우 가장 오래된 데이터를 제거한 후 새로운 데이터를 추가한다.</p>\n<p>원형 큐의 특성상 가장 오래된 데이터의 위치는 <code>head</code>에 저장되어 있다. 따라서 <code>head</code>를 한칸씩 증가시킴으로써 가장 오래된 데이터를 제거하고 새로운 데이터를 추가할 공간을 만들어 준다.</p>\n<p>새로운 데이터를 큐의 <code>tail</code> 위치에 복사합니다. 이때 std::memcpy 함수를 사용하여 새로운 데이터를 큐에 복사합니다. 그리고 tail_을 한 칸 증가시켜 다음 데이터가 저장될 위치를 나타낸다.</p>\n<p>이렇게 함으로써 큐의 크기를 넘어가는 경우 가장 오래된 데이터를 제거하고 새로운 데이터를 추가할 수 있게된다.</p>\n<h3 id=\"데이터-가져오기\"><a href=\"#데이터-가져오기\" class=\"headerlink\" title=\"데이터 가져오기\"></a>데이터 가져오기</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">Dequeue</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (size_ == <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nullptr</span>;<br>    &#125;<br>    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span>* value = data_[head_];<br>    head_ = (head_ + <span class=\"hljs-number\">1</span>) % MAX_BUFFER_SIZE;<br>    size_--;<br>    <span class=\"hljs-keyword\">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>가장 오래된 데이터를 큐에서 가져온다.</p>\n<p>큐가 비어있지 않는 경우 큐에서 가장 오래된 데이터를 가져와야한다. 이를 위해 <code>head</code>가 가리키는 위치에 있는 데이터를 가져와 <code>value</code>에 저장한다. 그리고 <code>head</code>를 한 칸 증가시켜 다음으로 가져올 데이터의 위치를 나타낸다.</p>\n<p>마지막으로, 큐의 크기를 하나 줄여주고 가져온 데이터를 반환한다.</p>\n<p>이를 통해 데이터가 큐의 크기를 넘어가게 되면 가장 오래된 데이터를 지우고 순차적으로 데이터를 배치할 수 있다.</p>\n<h2 id=\"Finish\"><a href=\"#Finish\" class=\"headerlink\" title=\"Finish\"></a>Finish</h2><p>이러한 데이터를 처리하는 작업은 하지 않아서 메모리 문제가 발생했을 때 당황했었다. 다행히 선배들이 방법을 알려줘서 쉽게 해결할 수 있었다. 무지 무지 감사합니다~</p>\n<p>덕분에 메모리가 터치지 않고, 웹에서 웹캠에 새그멘테이션을 적용하고 있다. 좀 더 최적화 해야하고 API도 다듬도 할게 많다!</p>\n","tags":["c++","memory-management","data-processing","queue","dynamic-memory-allocation"]},{"title":"첫번째 애프터 이펙트","url":"/2024/08/19/my-first-aftereffect/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>관심 있는 분야이기도 하니 설치해서 내장되어 있는 튜토리얼을 따라해봤다!</p>\n<p><img src=\"/../images/my-first-aftereffect.md/01_Color_VFX.webp\" alt=\"alt text\"></p>\n<p>CC Rainfall 효과와 Lumetri 색상을 설정해주었다.</p>\n<h2 id=\"blah\"><a href=\"#blah\" class=\"headerlink\" title=\"blah\"></a>blah</h2><p>우선 프로그램 내에서 튜토리얼을 할 수 있다는 것이 아주 마음에 든다.</p>\n<p><img src=\"/../images/my-first-aftereffect.md/image.webp\" alt=\"alt text\"></p>\n<ul>\n<li>레이어 개념이 있다는 것이 신기하다.</li>\n<li>각 레이어 자식에는 컴포넌트들(게임 엔진 개념으로)이 존재한다.</li>\n<li>변형은 Transform으로 이해해도 좋을 듯.</li>\n</ul>\n<p><img src=\"/../images/my-first-aftereffect.md/image-1.webp\" alt=\"alt text\"></p>\n<ul>\n<li>컴포넌트 안에는 값을 조절할 수 있는 변수들이 존재하며, 값을 바꾸면 이미지처리를 해주는 것으로 추정된다.</li>\n</ul>\n<p>프로그래밍을 활용하여 할 수 있는 방법을 찾는 것이 목표!</p>\n","tags":["aftereffect"]},{"title":"나의 WASM 프로젝트 세팅","url":"/2023/02/19/my-wasm-project-setting/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>emscripten은 c++을 이용해서 웹프로그래밍을 할 수 있다는 것이 너무 매력적이다.<br>회사 업무로적이나 개인적으로나 관심이 많아 이것저것 시도해보고 있다. 내가 사용하는 방법을 정리하고자 한다.</p>\n<h2 id=\"기본적인-방법\"><a href=\"#기본적인-방법\" class=\"headerlink\" title=\"기본적인 방법\"></a>기본적인 방법</h2><p><a href=\"https://emscripten.org/docs/getting_started/downloads.html\">emscripten 공식 홈페이지</a>에서 안내하는 방법이다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Get the emsdk repo</span><br>git clone https://github.com/emscripten-core/emsdk.git<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Enter that directory</span><br>cd emsdk<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Fetch the latest version of the emsdk (not needed the first time you <span class=\"hljs-built_in\">clone</span>)</span><br>git pull<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Download and install the latest SDK tools.</span><br>./emsdk install latest<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Make the <span class=\"hljs-string\">&quot;latest&quot;</span> SDK <span class=\"hljs-string\">&quot;active&quot;</span> <span class=\"hljs-keyword\">for</span> the current user. (writes .emscripten file)</span><br>./emsdk activate latest<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Activate PATH and other environment variables <span class=\"hljs-keyword\">in</span> the current terminal</span><br>source ./emsdk_env.sh<br></code></pre></td></tr></table></figure>\n<p>git에서 <code>sdk</code>를 설치한 후 원하는 <code>emscripten</code> 버전을 설치. 그 다음 활성화 하는 것이다.</p>\n<p>그 후 빌드를 하면 된다. <code>emcc</code> 명령어에 빌드할 파일을 추가시키면 된다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">./emcc test/hello_world.c -o hello.html<br></code></pre></td></tr></table></figure>\n<p><code>html</code> 파일도 같이 얻고 싶기 위해서 <code>-o</code> 명령어를 사용해 <code>html</code>을 얻는다.<br>자세한 내용은 <a href=\"https://emscripten.org/docs/getting_started/Tutorial.html\">여기서</a> 확인하면 된다.</p>\n<p>하지만 파일이 하나라면 이 방법이 편한데 만약 프로젝트가 크다면 불편하다. cmake를 이용해 빌드하는 방법을 주로 사용한다.</p>\n<h2 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h2><p>나의 프로젝트 구성은 다음과 같다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">.<br>|____cpp<br>| |____CMakeLists.txt<br>| |____src<br>| | |____main.cpp<br>|____web<br></code></pre></td></tr></table></figure>\n<p><code>cpp</code> 폴더에는 c++ 프로젝트에 대한 것을 다 포함 시킨다.<code>web</code> 폴더에는 web에 관한 파일들을 포함 시킬 예정이다.</p>\n<p>CMakeFile 내용은 다음과 같다.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">cmake_minimum_required</span>(VERSION <span class=\"hljs-number\">3.0</span>.<span class=\"hljs-number\">0</span>)<br><span class=\"hljs-keyword\">project</span>(EmscriptenProject VERSION <span class=\"hljs-number\">0.1</span>.<span class=\"hljs-number\">0</span>)<br><br><br><span class=\"hljs-keyword\">add_executable</span>(EmscriptenProject src/main.cpp)<br><br><span class=\"hljs-keyword\">if</span>(EMSCRIPTEN)<br><span class=\"hljs-keyword\">set</span>(OUTPUT_DIR <span class=\"hljs-variable\">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/../web/src)<br><span class=\"hljs-keyword\">set_target_properties</span>(EmscriptenProject PROPERTIES<br>    RUNTIME_OUTPUT_DIRECTORY <span class=\"hljs-variable\">$&#123;OUTPUT_DIR&#125;</span><br>    SUFFIX <span class=\"hljs-string\">&quot;.html&quot;</span><br>    LINK_FLAGS <span class=\"hljs-string\">&quot;-s WASM=1&quot;</span><br>)<br><br><span class=\"hljs-keyword\">endif</span>()<br></code></pre></td></tr></table></figure>\n<p><code>OUTPUT_DIR</code>에 export할 <code>.wasm</code>, <code>.js</code>, <code>.html</code> 경로를 설정해준다.<br><code>SUFFIX</code>으로 <code>html</code> 파일이 익스포트할 거라고 알리고 <code>LINK_FLAGS</code>에 emscripten 옵션을 추가해주면 된다. <a href=\"https://emscripten.org/docs/tools_reference/emcc.html\">여기서</a> 확인하고 필요한 옵션을 추가하면 된다.</p>\n<p>해당 <code>main.cpp</code>는 <code>hello world</code>를 출력하는거라서 많은 옵션을 추가하지 않았다.</p>\n<p>빌드 명령어는 다음과 같다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">cmake -S . -B ./.web-build --toolchain ./emsdk/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake<br>cmake --build ./.web-build --config Release<br></code></pre></td></tr></table></figure>\n<p><code>CMakeLists.txt</code> 파일이 존재하는 경로에서 실행하면 된다. 여기서 <code>--toolchain</code> 다음 부분에 자신의 emsdk 경로를 추가하면 된다.</p>\n<p>빌드 후 파일 구조는 다음과 같다(기타 파일들을 가렸다).</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">.<br>|____web<br>| |____src<br>| | |____EmscriptenProject.js<br>| | |____EmscriptenProject.wasm<br>| | |____EmscriptenProject.html<br>|____cpp<br>| |____CMakeLists.txt<br>| |____.web-build<br>| |____src<br>| | |____main.cpp<br></code></pre></td></tr></table></figure>\n<p><code>web/scr</code>에 파일이 추가된 것을 확인할 수 있다. html을 바로 클릭하면 실행할 수 없다. XHR 요청을 지원하지 않으면 <code>.wasm</code> 파일을 요청할 수 없기 때문이다. 로컬 웹서버를 사용해야한다. 나는 주로 <code>vscode</code>의 <a href=\"https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer\">Live Server</a>를 사용한다.</p>\n<p>html을 실행하면 <code>hello world!</code>가 출력되는 것을 확인할 수 있다.</p>\n<h2 id=\"쉘-스크립트-작성\"><a href=\"#쉘-스크립트-작성\" class=\"headerlink\" title=\"쉘 스크립트 작성\"></a>쉘 스크립트 작성</h2><p>명령어를 일일히 입력하기 귀찮기 때문에 쉘 스크립트를 추가한다. 우선 emscripten을 설치하는 스크립트를 작성했다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># install_emsdk.sh</span><br><br>DIRECTORY=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( cd <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span> )</span>&quot;</span> &amp;&amp; pwd -P )</span>&quot;</span><br><br><span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$&#123;DIRECTORY&#125;</span><br><br><span class=\"hljs-comment\"># Get the emsdk repo</span><br>git <span class=\"hljs-built_in\">clone</span> https://github.com/emscripten-core/emsdk.git<br><br><span class=\"hljs-comment\"># Enter that directory</span><br><span class=\"hljs-built_in\">cd</span> emsdk<br><br><span class=\"hljs-comment\"># Fetch the latest version of the emsdk (not needed the first time you clone)</span><br>git pull<br><br><span class=\"hljs-comment\"># Download and install the latest SDK tools.</span><br>./emsdk install latest<br><br><span class=\"hljs-comment\"># Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes .emscripten file)</span><br>./emsdk activate latest<br></code></pre></td></tr></table></figure>\n<p>최초 1회만 실행하면 된다. 그러면 <code>install_emsdk.sh</code> 가 위치한 곳에 <code>emsdk</code>를 다운받고 설치한다.</p>\n<p>그 다음 빌드 명령어도 스크립트로 만든다.</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># build_web.sh</span><br>CURRENT_DIRECTORY=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( cd <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$0</span>&quot;</span> )</span>&quot;</span> &amp;&amp; pwd -P )</span>&quot;</span><br>EMSDK=<span class=\"hljs-variable\">$&#123;CURRENT_DIRECTORY&#125;</span>/emsdk<br><br>cmake -S <span class=\"hljs-variable\">$&#123;CURRENT_DIRECTORY&#125;</span> -B <span class=\"hljs-variable\">$&#123;CURRENT_DIRECTORY&#125;</span>/.web-build --toolchain <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$&#123;EMSDK&#125;</span>/upstream/emscripten/cmake/Modules/Platform/Emscripten.cmake&quot;</span><br>cmake --build <span class=\"hljs-variable\">$&#123;CURRENT_DIRECTORY&#125;</span>/.web-build --config Release<br></code></pre></td></tr></table></figure>\n<p>쉘 스크립트 실행으로 빌드까지 할 수 있다. 쉘 스크립트 위치는 <code>cpp</code> 폴더에 포함 시켰다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">.<br>|____web<br>| |____src<br>| | |____EmscriptenProject.js<br>| | |____EmscriptenProject.wasm<br>| | |____EmscriptenProject.html<br>|____cpp<br>| |____CMakeLists.txt<br>| |____build_web.sh<br>| |____install_emsdk.sh<br>| |____.web-build<br>| |____src<br>| | |____main.cpp<br></code></pre></td></tr></table></figure>\n<p>빌드 까지 완료한 파일 구조이다.</p>\n<h2 id=\"샘플-프로젝트\"><a href=\"#샘플-프로젝트\" class=\"headerlink\" title=\"샘플 프로젝트\"></a>샘플 프로젝트</h2><p>저장소를 만들었으니 여기서 확인하면 된다.<br><a href=\"https://github.com/keea/sample-emscripten-project-template\">https://github.com/keea/sample-emscripten-project-template</a></p>\n<h2 id=\"여담\"><a href=\"#여담\" class=\"headerlink\" title=\"여담\"></a>여담</h2><p>우선 간단한 샘플 만드는 것부터 정리했다. 그 외에 다양한 방법을 연구한 것이 있는데 추후에 문서를 작성하고 여기에 추가하도록 하겠다. 예를 들어 js만 뽑아서 번들링 한다던가… 리엑트와 연동시킨다던가 등등!!</p>\n<p>그리고 샘플 저장소의 README는 ChatGPT가 적어줬다.</p>\n","tags":["emscripten","wasm","c++"]},{"title":"나의 WASM 프로젝트 세팅 - embind","url":"/2023/03/25/my-wasm-project-setting-embind/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p><a href=\"2023/02/19/my-wasm-project-setting/\">이전글</a> 에서 c++ 코드를 웹에서 실행할 수 있게 되었다. 하지만 이전에는 main함수의 내용을 바로 실행했다면 이번에는 c++ 함수나 클래스를 자바스크립트에서 호출하고자 한다!!</p>\n<h2 id=\"embind\"><a href=\"#embind\" class=\"headerlink\" title=\"embind\"></a>embind</h2><p>embind는 c++ 함수나 클래스를 자바스크립트에 바인딩 하는 기술이다. 위에서 말했듯이 c++ 함수나 클래스를 자바스크립트에서 호출 하거나, c++ 객체를 생성할 수 있다.</p>\n<h2 id=\"embind-사용-방법\"><a href=\"#embind-사용-방법\" class=\"headerlink\" title=\"embind 사용 방법\"></a>embind 사용 방법</h2><p><code>EMSCRIPTEN_BINDINGS</code> 매크로를 사용하여 C++ 코드에서 바인딩 할 클래스 및 함수를 정의하면 된다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;emscripten/bind.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-built_in\">EMSCRIPTEN_BINDINGS</span>(add_binding) &#123;<br>  emscripten::<span class=\"hljs-built_in\">function</span>(<span class=\"hljs-string\">&quot;Add&quot;</span>, &amp;Add);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>int Add(int, int)</code> 함수를 자바스크립트에서 노출할 수 있도록 했다.</p>\n<p>해당 코드를 <code>lembind</code> 옵션을 사용하여 컴파일 하면 된다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">emcc -lembind -o add.js add.cpp<br></code></pre></td></tr></table></figure>\n\n<p>웹에서는 다음과 같이 사용하면 된다.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-title class_\">Module</span> = &#123;</span><br><span class=\"language-javascript\">      <span class=\"hljs-attr\">onRuntimeInitialized</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;</span><br><span class=\"language-javascript\">        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;lerp result: &#x27;</span> + <span class=\"hljs-title class_\">Module</span>.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>));</span><br><span class=\"language-javascript\">      &#125;</span><br><span class=\"language-javascript\">    &#125;;</span><br><span class=\"language-javascript\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;add.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure>\n<p><code>onRuntimeInitialized</code>를 사용하여 런타임이 준비되었을 때 코드를 실행한다.</p>\n<h2 id=\"번들링\"><a href=\"#번들링\" class=\"headerlink\" title=\"번들링\"></a>번들링</h2><p>물론 c++로 뽑아낸 자바스크립트만 사용하는 경우도 있지만 다른 자바스크립트들과 사용할 경우 묶어서 사용하는 번들링 기술을 사용하는 것도 좋다고 생각해서 번들링을 설정했다.</p>\n<h3 id=\"Rollup\"><a href=\"#Rollup\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h3><p>여러가지 번들링 도구 중 Rollup을 사용한 큰 이유는 없다. 그냥 내가 보기에 간단해 보이고 성공했기 때문이다. </p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p>필요한 플러그인을 다운받았다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">npm install -D rollup @rollup/plugin-commonjs @rollup/plugin-node-resolve rollup-plugin-polyfill-node<br></code></pre></td></tr></table></figure>\n<ul>\n<li>@rollup&#x2F;plugin-commonjs : CommonJS 모듈 형식으로 작성된 코드를 ES 모듈 형식으로 변환한다.</li>\n<li>@rollup&#x2F;plugin-node-resolve : 외부 모듈(node_modules) 사용 시 사용한다.</li>\n<li>rollup-plugin-polyfill-node : Node.js 환경에서 사용 가능한 전역 객체나 함수를 브라우저에서 사용할 수 있도록 polyfill을 제공한다.</li>\n</ul>\n<p>이러한 용도로 해당 플러그인을 설정했다.</p>\n<h2 id=\"Setting\"><a href=\"#Setting\" class=\"headerlink\" title=\"Setting\"></a>Setting</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs .js\">import commonjs from &#x27;@rollup/plugin-commonjs&#x27;;<br>import &#123;nodeResolve&#125; from &#x27;@rollup/plugin-node-resolve&#x27;;<br>import nodePolyfills from &#x27;rollup-plugin-polyfill-node&#x27;;<br><br>export default &#123;<br>  input: &#x27;index.js&#x27;,<br>  output: &#123;<br>    file: &#x27;./dist/index.js&#x27;,<br>    format: &#x27;umd&#x27;,<br>    name: &#x27;Wasm&#x27;,<br>  &#125;,<br>  plugins: [nodeResolve(), commonjs(), nodePolyfills()]<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>index.js를 진입점으로 설정하고 output 설정을 해주었다. format은 umd를 사용하여 모듈 방식을 커버할 수 있도록 했다.</p>\n<p>이제 wasm 글루코드를 번들링해보도록 한다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">-s WASM=1 -lembind -s MODULARIZE=1 -s &#x27;EXPORT_NAME=\\&quot;wasm\\&quot;&#x27;<br></code></pre></td></tr></table></figure>\n<p>옵션은 다음과 같이 지정했다.</p>\n<p><code>MODULARIZE</code>을 추가한 이유는 익스포트한 자바스크립트가 모듈 형태로 되는 것도 있고, 이 모듈이 factory 함수 형태 반환하는데 factory 함수를 호출하면, 생성된 모듈이 다운로드되고 인스턴스화되는 과정이 진행되며 factory 함수가 반환하는 Promise가 resolved가 된다고 한다.</p>\n<p>로딩이 완료되는 시점에 c++로 바인딩한 함수를 사용할 수 있게 된다. 로드가 안된 상태에서 불러오는 불상사를 막을 수 있다.</p>\n<p><a href=\"https://emscripten.org/docs/getting_started/FAQ.html#how-can-i-tell-when-the-page-is-fully-loaded-and-it-is-safe-to-call-compiled-functions\">https://emscripten.org/docs/getting_started/FAQ.html#how-can-i-tell-when-the-page-is-fully-loaded-and-it-is-safe-to-call-compiled-functions</a> 해당 링크를 확인하면 된다.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> wasm <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./src/EmscriptenProject.js&#x27;</span>;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Init</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">let</span> wasmModule;<br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">wasm</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">Module</span>) &#123; wasmModule = <span class=\"hljs-title class_\">Module</span> &#125;);<br>    <span class=\"hljs-keyword\">return</span> wasmModule;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> &#123;<span class=\"hljs-title class_\">Init</span>&#125;;<br></code></pre></td></tr></table></figure>\n<p>롤업의 input인 <code>index.js</code>이다. 간단하게 모듈을 로드를 하고 완료되면 모듈을 반환하도록 만들었다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">rollup -c<br></code></pre></td></tr></table></figure>\n<p>해당 명령어를 통해 번들링을 진행하면 <code>dist</code>폴더에 번들링된 <code>index.js</code> 파일이 생긴다. 여기서 주의할 점은 <code>dist</code>폴더 안에 <code>.wasm</code>파일도 있어야한다. 이 경로로 <code>.wasm</code> 파일을 옮겨주면 된다.</p>\n<p><code>html</code> 스크립트를 로드하고 사용하면 된다.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!doctype <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;index.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;Module&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">var</span> wasmModule = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Wasm</span>.<span class=\"hljs-title class_\">Init</span>();</span><br><span class=\"language-javascript\">    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(wasmModule.<span class=\"hljs-title class_\">Add</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>));</span><br><span class=\"language-javascript\">  </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>html의 로그를 확인해보면 c++로 바인딩한 Add함수가 실행되는 것을 알 수 있다.</p>\n<h2 id=\"스크립트-작업\"><a href=\"#스크립트-작업\" class=\"headerlink\" title=\"스크립트 작업\"></a>스크립트 작업</h2><p>현재는 c++ 빌드 -&gt; 번들링하는 작업 이렇게 2가지 작업이 진행된다. 이걸 자동화를 해보자.</p>\n<p><a href=\"2023/02/19/my-wasm-project-setting/\">이전글</a> 빌드 명령어 스크립트를 실행하면 번들링까지 되도록 하면 된다.</p>\n<p><code>CMakeLists.txt</code>에 다음의 코드를 추가하면 된다.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">set(ROLLUP_OPTS $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../web/rollup.config.mjs)<br>ADD_CUSTOM_COMMAND(TARGET EmscriptenProject <br>    COMMAND cd $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../web &amp;&amp; npx rollup -c $&#123;ROLLUP_OPTS&#125;<br>    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy $&#123;OUTPUT_DIR&#125;/EmscriptenProject.wasm $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../web/dist<br>    )<br></code></pre></td></tr></table></figure>\n<p>소스 코드가 빌드 될 때 실행되는 커스텀 명령어를 정의했다. 웹 관련 코드가 저장되어 있는 디렉토리로 작업 디렉토리를 변경하고, 롤업의 설정파일을 실행했다. 그러면 롤업 설정에 따라 dist 디렉토리에 번들링한 index.js가 생성되었을 것이다.<br>그 다음 코드는 <code>wasm</code> 파일을 dist 파일로 복사한다.</p>\n<p>이러면 c++ 빌드할 때 자동으로 번들링까지 진행된다!!!</p>\n<p>이제 취향껏 package.json의 scripts에 작성을 추가하면 된다.</p>\n<h2 id=\"여담\"><a href=\"#여담\" class=\"headerlink\" title=\"여담\"></a>여담</h2><p>자바스크립트나 웹 환경을 잘 모르는 초보 개발자가 해냈습니다. 추후에 라이브러리나 SDK로 배포를 하게 된다면 최종적으로 사용자가 쓰는 부분은 깔끔하게 간단하게 쓰이는 것이 좋다고 생각해서 이것저것 조사해보고 시행착오 끝냈다.</p>\n<p>나름 검색해도 정보가 사혼의 조각처럼 흩어졌기 때문에 정리했다!! 이제는 좀 더 작게작게 emscripten의 팁을 올려야겠다.</p>\n","tags":["emscripten","wasm","c++"]},{"title":"WebAssembly 디버깅용 CMake 설정","url":"/2025/08/10/wasm-debugging-with-cmake/","content":"<p>크롬 개발자 도구에서 WASM 디버깅을 하려면 디버깅 정보와 최적화 비활성화가 필요하다.</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><code class=\"hljs cmake\"><span class=\"hljs-keyword\">add_compile_options</span>(-g -O0)  <span class=\"hljs-comment\"># 디버깅용 (최적화 없음)</span><br><span class=\"hljs-keyword\">add_link_options</span>(-g -O0)     <span class=\"hljs-comment\"># 디버깅용 (최적화 없음)</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>-g</code> : 디버깅 정보를 생성해 소스 코드 단위 디버깅 가능.</li>\n<li><code>O0</code> : 최적화를 끄고 원래 코드 구조 유지.</li>\n</ul>\n<p>최적화를 커면 컴파일러가 코드를 재배치하거나 생략하기 때문에, 디버깅 시 변수값 추적이 어려워진다.<br>따라서 WASM 디버깅을 할 땐 <code>-O0</code>로 최적화를 끄고, 크롬 개발자 도구를 활용해 중단점 설정, 변수 확인 등을 진행해야 한다.</p>\n<p>자세한 내용은 <a href=\"https://developer.chrome.com/docs/devtools/wasm?hl=ko\">크롬 공식 문제</a> 참고.</p>\n","tags":["wasm","webassembly","cmake"]},{"title":"언리얼 엔진에서의 공격 애니메이션 작업기","url":"/2024/02/28/unreal-engine-attack-animation-work-log/","content":"<div class=\"note warning\"><svg aria-hidden=\"true\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"exclamation-circle\" class=\"svg-inline--fa fa-exclamation-circle icon\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"><path fill=\"currentColor\" d=\"M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z\"></path></svg><header>Warning</header><p>이 내용은 2019년에 작성된 내용입니다.</p></div>\n<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL:DR\"></a>TL:DR</h2><blockquote>\n<p>마우스 클릭 시 공격 애니메이션 재생.</p>\n</blockquote>\n<p>공격 애니메이션을 어떻게 추가할까 고민하다가 애니메이션 스테이트 머신에 적용할려고 했다.<br>하지만 강좌를 찾는 도중에 이 강좌를 찾았다!</p>\n<p><a href=\"https://youtu.be/cWWuDf2ZUj0?list=PLCeaAi_Ah78SEV2Q-iVuFbe6xOtQYH6sH\">https://youtu.be/cWWuDf2ZUj0?list=PLCeaAi_Ah78SEV2Q-iVuFbe6xOtQYH6sH</a></p>\n<h2 id=\"몽타주-추가\"><a href=\"#몽타주-추가\" class=\"headerlink\" title=\"몽타주 추가\"></a>몽타주 추가</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//melee attack montage</span><br><span class=\"hljs-built_in\">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = Animation, meta = (AllowPrivateAccess = <span class=\"hljs-string\">&quot;true&quot;</span>))<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UAnimMontage</span>* MeleeAttackMontage;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//몽타주 읽기.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ConstructorHelpers::FObjectFinder&lt;UAnimMontage&gt; <span class=\"hljs-title\">MeleeAttackMontageObject</span><span class=\"hljs-params\">(TEXT(<span class=\"hljs-string\">&quot;AnimMontage&#x27;/Game/Animation/PrimaryAttack_C_Slow_Montage1.PrimaryAttack_C_Slow_Montage1&#x27;&quot;</span>))</span></span>;<br><br><span class=\"hljs-keyword\">if</span> (MeleeAttackMontageObject.<span class=\"hljs-built_in\">Succeeded</span>()) &#123;<br>\t\tMeleeAttackMontage = MeleeAttackMontageObject.Object;<br>    &#125;<br></code></pre></td></tr></table></figure>\n<p>몽타주는 기존에 있는 것을 팔라곤 에셋인 것을 사용하기로 하고 몽타주는 따로 제작하지 않았다.<br>몽타주를 읽기 위해서 프로젝트 폴더내에 있는 몽타주를 가져와서 읽는데 경로는 해당하는 레퍼런스 복사를 누르면 된다.</p>\n<blockquote>\n<p>20.06 나중에 리소스 삭제할려고 할 때 레퍼런스 참조로 삭제가 힘들게 뜬다. 삭제한다고 하면, 나중에 컴파일 때 엔진이 크래시나는 문제가 있다. 블루프린터로 따로 빼서 리소스를 등록하게 하는 것이 편하다.</p>\n</blockquote>\n<p><img src=\"/images/unreal-engine-attack-animation-work-log.md/image.webp\" alt=\"alt text\"></p>\n<h2 id=\"몽타주-실행-함수\"><a href=\"#몽타주-실행-함수\" class=\"headerlink\" title=\"몽타주 실행 함수\"></a>몽타주 실행 함수</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::AttackStart</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">PlayAnimMontage</span>(MeleeAttackMontage, <span class=\"hljs-number\">-1.f</span>, <span class=\"hljs-built_in\">FName</span>(<span class=\"hljs-string\">&quot;Default&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>설정해놓은 몽타주 애니메이션을 재생시킨다.</p>\n<h2 id=\"키-맵핑\"><a href=\"#키-맵핑\" class=\"headerlink\" title=\"키 맵핑\"></a>키 맵핑</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">PlayerInputComponent-&gt;<span class=\"hljs-built_in\">BindAction</span>(<span class=\"hljs-string\">&quot;Attack&quot;</span>, IE_Pressed, <span class=\"hljs-keyword\">this</span>, &amp;AMyPlayer::AttackStart);<br>PlayerInputComponent-&gt;<span class=\"hljs-built_in\">BindAction</span>(<span class=\"hljs-string\">&quot;Attack&quot;</span>, IE_Released, <span class=\"hljs-keyword\">this</span>, &amp;AMyPlayer::AttackEnd);<br></code></pre></td></tr></table></figure>\n<p>마우스 키를 눌렸을 때 만들어준 AttackStart 함수를 호출하고 마우스 키를 뗄 떼는 AttackEnd함수를 호출한다. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::AttackEnd</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGEngine-&gt;<span class=\"hljs-built_in\">AddOnScreenDebugMessage</span>(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">5.0f</span>, FColor::Blue, __FUNCTION__);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>AttackEnd는 별 것 없다. 그냥 쉽게 로그를 확인하기 위해서이다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/atk.webp\" alt=\"alt text\"><br>뭔가 끝나는 동작이 이상하다. 애니메이션이 검을 내리고 빠르게 원상 복귀가 되는 것이다.</p>\n<p>2019&#x2F;11&#x2F;12</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><code class=\"hljs diff\"><span class=\"hljs-deletion\">- PlayAnimMontage(MeleeAttackMontage, -1.f, FName(&quot;Default&quot;));</span><br><span class=\"hljs-addition\">+ PlayAnimMontage(MeleeAttackMontage, +1.f, FName(&quot;Default&quot;));</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>-1.f가 아니라 1로하면 자연스럽게 애니메이션이 재생된다. 난 바보 같이 -1로 한거나….ㅠㅠ</p>\n</blockquote>\n<h2 id=\"검에-콜라이더-추가\"><a href=\"#검에-콜라이더-추가\" class=\"headerlink\" title=\"검에 콜라이더 추가.\"></a>검에 콜라이더 추가.</h2><p>애니메이션이 재생되었다고해도 콜라이더를 붙여서 다른 오브젝트와 충돌 상호작용을 해야한다.</p>\n<p>그래서 박스 콜라이더를 붙여보았다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">UPROPERTY</span>(VisibleAnywhere, BlueprintReadOnly, Category = Attack)<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UBoxComponent</span>* MeleeCollisionBox;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\">MeleeCollisionBox = <span class=\"hljs-built_in\">CreateDefaultSubobject</span>&lt;UBoxComponent&gt;(<span class=\"hljs-built_in\">TEXT</span>(<span class=\"hljs-string\">&quot;MeleeCollisionBox&quot;</span>));<br>MeleeCollisionBox-&gt;<span class=\"hljs-built_in\">SetupAttachment</span>(RootComponent);<br>MeleeCollisionBox-&gt;<span class=\"hljs-built_in\">SetCollisionProfileName</span>(<span class=\"hljs-string\">&quot;NoCollision&quot;</span>);<br>MeleeCollisionBox-&gt;<span class=\"hljs-built_in\">SetHiddenInGame</span>(<span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n<p>하지만 원하는 것은 검의 움직임에 따라 같이 콜라이더가 움직이는 것인데 그렇지 않다. ㅠㅠ</p>\n<p><a href=\"https://youtu.be/IWnSlOmVhTM?list=PLCeaAi_Ah78SEV2Q-iVuFbe6xOtQYH6sH\">https://youtu.be/IWnSlOmVhTM?list=PLCeaAi_Ah78SEV2Q-iVuFbe6xOtQYH6sH</a></p>\n<p>하지만 그 다음 강좌에 콜라이더를 붙이는 강좌가 있다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::BeginPlay</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tSuper::<span class=\"hljs-built_in\">BeginPlay</span>();<br>\t<span class=\"hljs-comment\">//attach collision components to sockets based on transformation definnate</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> FAttachmentTransformRules <span class=\"hljs-title\">AttackmentRules</span><span class=\"hljs-params\">(EAttachmentRule::SnapToTarget, EAttachmentRule::SnapToTarget, EAttachmentRule::KeepWorld, <span class=\"hljs-literal\">false</span>)</span></span>;<br>\tMeleeCollisionBox-&gt;<span class=\"hljs-built_in\">AttachToComponent</span>(<span class=\"hljs-built_in\">GetMesh</span>(), AttackmentRules, <span class=\"hljs-string\">&quot;weapon_r_collison&quot;</span>);<br>\t<span class=\"hljs-built_in\">GetCapsuleComponent</span>()-&gt;OnComponentBeginOverlap.<span class=\"hljs-built_in\">AddDynamic</span>(<span class=\"hljs-keyword\">this</span>, &amp;AMyPlayer::OnOverlapBegin);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>부착 규칙을 설정해서 콜라이더를 붙여준다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/image-2.webp\" alt=\"alt text\"><br>해당 메시의 스켈레톤의 “weapon_r_collision”의 중심점으로 만든 콜라이더가 붙는다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/attack.webp\" alt=\"alt text\"><br>콜라이더가 검의 움직임에 맞춰서 동작하는 것을 볼 수 있다!!!!</p>\n<p>상호 작용하는 모습은 다음과 같다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/attack1.webp\" alt=\"alt text\"></p>\n<h2 id=\"콤보-공격-만들기\"><a href=\"#콤보-공격-만들기\" class=\"headerlink\" title=\"콤보 공격 만들기\"></a>콤보 공격 만들기</h2><p><img src=\"/images/unreal-engine-attack-animation-work-log.md/image-3.webp\" alt=\"alt text\"><br>기획서상에 콤보 공격이 존재한다!!! 앞에서 한 것은 콤보공격을 위한 준비과정일뿐.</p>\n<p><a href=\"http://joyeeeeeee.blogspot.com/2017/11/unreal491-combo.html\">http://joyeeeeeee.blogspot.com/2017/11/unreal491-combo.html</a></p>\n<p>콤보 공격의 아이디어를 여기서부터 출발했다. 애니메이션 몽타주를 배열로 만든 다음 콤보 수를 배열의 인덱스로 사용하여 재생시키기로 했다!!!!</p>\n<h3 id=\"몽타주-배열-정의\"><a href=\"#몽타주-배열-정의\" class=\"headerlink\" title=\"몽타주 배열 정의\"></a>몽타주 배열 정의</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">UPROPERTY</span>(EditDefaultsOnly, BlueprintReadOnly, Category = Animation, meta = (AllowPrivateAccess = <span class=\"hljs-string\">&quot;true&quot;</span>))<br>TArray&lt;UAnimMontage * &gt;MeleeAttackMontages;<br></code></pre></td></tr></table></figure>\n<p>공격 몽타주를 정의해준다. 언리얼에서는 배열을 <code>TArray</code>로 사용한다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ConstructorHelpers::FObjectFinder&lt;UAnimMontage&gt; <span class=\"hljs-title\">MeleeAttackMontageObject1</span><span class=\"hljs-params\">(TEXT(<span class=\"hljs-string\">&quot;AnimMontage&#x27;/Game/Animation/PrimaryAttack_A_Slow_Montage1.PrimaryAttack_A_Slow_Montage1&#x27;&quot;</span>))</span></span>;<br><span class=\"hljs-keyword\">if</span> (MeleeAttackMontageObject1.<span class=\"hljs-built_in\">Succeeded</span>()) &#123;<br>\tMeleeAttackMontages.<span class=\"hljs-built_in\">Add</span>(MeleeAttackMontageObject1.Object);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ConstructorHelpers::FObjectFinder&lt;UAnimMontage&gt; <span class=\"hljs-title\">MeleeAttackMontageObject2</span><span class=\"hljs-params\">(TEXT(<span class=\"hljs-string\">&quot;AnimMontage&#x27;/Game/Animation/PrimaryAttack_B_Slow_Montage1.PrimaryAttack_B_Slow_Montage1&#x27;&quot;</span>))</span></span>;<br><span class=\"hljs-keyword\">if</span> (MeleeAttackMontageObject2.<span class=\"hljs-built_in\">Succeeded</span>()) &#123;<br>\tMeleeAttackMontages.<span class=\"hljs-built_in\">Add</span>(MeleeAttackMontageObject2.Object);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> ConstructorHelpers::FObjectFinder&lt;UAnimMontage&gt; <span class=\"hljs-title\">MeleeAttackMontageObject3</span><span class=\"hljs-params\">(TEXT(<span class=\"hljs-string\">&quot;AnimMontage&#x27;/Game/Animation/PrimaryAttack_C_Slow_Montage1.PrimaryAttack_C_Slow_Montage1&#x27;&quot;</span>))</span></span>;<br><span class=\"hljs-keyword\">if</span> (MeleeAttackMontageObject3.<span class=\"hljs-built_in\">Succeeded</span>()) &#123;<br>\tMeleeAttackMontages.<span class=\"hljs-built_in\">Add</span>(MeleeAttackMontageObject3.Object);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>몽타주들을 배열에 넣어준다. 그러면 인덱스 값에 따라 몽타주들을 관리할 수 있다!</p>\n<p>그 다음 콤보에 대한 설정을 해준다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//콤보상태인가?</span><br><span class=\"hljs-type\">bool</span> m_bCombo;<br><br><span class=\"hljs-comment\">//콤보 공격 인덱스</span><br><span class=\"hljs-type\">int</span> m_iCombo;<br></code></pre></td></tr></table></figure>\n<p>두개의 변수를 만든다. 콤보 상태인가 아닌가를 구분해 줄 bool형 변수와 현재 콤보가 몇 인지 알려주는 변수 2개를 추가했다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::AttackStart</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//지금 콤보상태인지 아닌지 확인해본다.</span><br>\t<span class=\"hljs-keyword\">if</span> (m_bCombo) &#123;<br>\t\tm_iCombo = (m_iCombo + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">3</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-comment\">//콤보상태가 아닐경우 combo상태로 변환.</span><br>\t\tm_bCombo = <span class=\"hljs-literal\">true</span>;<br>\t\tm_iCombo = <span class=\"hljs-number\">0</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">PlayAnimMontage</span>(MeleeAttackMontages[m_iCombo], <span class=\"hljs-number\">1.f</span>, <span class=\"hljs-built_in\">FName</span>(<span class=\"hljs-string\">&quot;Default&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>공격을 했을 때 콤보 상태인지 아닌지를 확인해서 콤보 상태일 경우 콤보를 1증가시키고 아닐 경우에는 콤보 상태로 바꾸고, 콤보를 0으로 초기화시킨다. 그 이후 콤보 애니메이션을 재생시킨다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::AttackEnd</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tm_bCombo = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//콤보를 취소한다.</span><br>\tm_iCombo = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>AttackEnd함수에서 콤보를 취소시킨다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/attack2.webp\" alt=\"alt text\"><br>빠르게 첫 번째 애니메이션만 재생이 된다. ㅠㅠ 그 이유를 알아보니 AttackEnd함수는 마우스를 뗄 떼 콤보랑 콤보 상태가 초기화되기 때문이다. 애니메이션이 종료될 때 AttackEnd함수를 호출해야 한다.</p>\n<p>그렇다면 애니메이션이 끝날 때를 판단할 수 있을까?<br><a href=\"https://darkcatgame.tistory.com/4\">https://darkcatgame.tistory.com/4</a></p>\n<p>이 블로그를 참고하여 인터페이스 함수를 제작하고 그 함수를 호출시키는 Anim Notify 제작 후 연동시켰다.</p>\n<h3 id=\"Interface-Class-제작\"><a href=\"#Interface-Class-제작\" class=\"headerlink\" title=\"Interface Class 제작\"></a>Interface Class 제작</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// Itf_AnimationNotify.h</span><br><br><span class=\"hljs-comment\">//콤보가 취소될 때 호출</span><br><span class=\"hljs-built_in\">UFUNCTION</span>(BlueprintNativeEvent, BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Itf_AnimState&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Itf_ResetCombo</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>캐릭터 클래스에서 함수 정의를 해준다. 참고로 캐릭터 클래스는 Itf_AnimationNotify를 상속받아야 한다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// MyPlayer.h</span><br><br><span class=\"hljs-comment\">//콤보 리셋 메시지 받기.</span><br><span class=\"hljs-built_in\">UFUNCTION</span>(BlueprintNativeEvent, BlueprintCallable, Category = <span class=\"hljs-string\">&quot;Itf_AnimState&quot;</span>)<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Itf_ResetCombo</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Itf_ResetCombo_Implementation</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span></span>;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// MyPlayer.cpp</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::Itf_ResetCombo_Implementation</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tm_bCombo = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//콤보를 취소한다.</span><br>\tm_iCombo = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>인터페이스로 만든 함수가 호출 시 이 함수가 호출 될 것이다. 호출이 되면 애니메이션이 끝나게 되는 상황이기 때문에 콤보를 초기화 해준다.<br>그 다음 애니메이션에서 애니메이션이 끝나는 부분에 Interface함수를 호출해야 한다.</p>\n<p>그렇게 하기 위해서는 AnimNotify를 만들어 준 후 Anim Notify Blueprint 클래스를 제작해야한다.</p>\n<p><img src=\"/images/unreal-engine-attack-animation-work-log.md/image-4.webp\" alt=\"alt text\"></p>\n<p>AnimNotify Blueprint 클래스를 제작한다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/image-5.webp\" alt=\"alt text\"></p>\n<p>Interface함수를 호출하는 노드를 제작한다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/image-6.webp\" alt=\"alt text\"></p>\n<p>원하는 애니메이션 시점에 만들어준 Notify를 추가하면 된다. 이렇게 해서 끝나는 시점까지 누르지 않으면 콤보가 초기화 되는 조작을 하게 되었다. </p>\n<p>그런데 말입니다….<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/222.webp\" alt=\"alt text\"><br>누르는 속도에 따라 엄청나게 빠르게 칼질하는 플레이어의 모습을 볼 수 있다. </p>\n<p>이렇게 되는 이유는 마우스 클릭할 때마다 AttackStart()의 애니메이션이 재생되기 때문이다. 자연스러운 동작을 보고 싶으면 애니메이션이 끝날 때 콤보가 있을 경우 다음 애니메이션으로 보여주게 하는 것이다.</p>\n<p>그러면 우선 AttackStart부분을 수정해야 한다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// MyPlayer.cpp</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::AttackStart</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//attack이 true 일 때 클릭하면 </span><br>\t<span class=\"hljs-keyword\">if</span> (m_bAttack) &#123;<br>\t\t<span class=\"hljs-comment\">//콤보상태를 true한다.</span><br>\t\tm_bCombo = <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123;<span class=\"hljs-comment\">//그렇지 않을 경우 </span><br>\t\t<span class=\"hljs-comment\">//m_bAttack 상태를 true 바꾸고, 콤보도 0으로 바꾸고</span><br>\t\tm_bAttack = <span class=\"hljs-literal\">true</span>; m_iCombo = <span class=\"hljs-number\">0</span>;<br><br>\t\t<span class=\"hljs-comment\">//애니메이션을 재생시킨다.</span><br>\t\tGEngine-&gt;<span class=\"hljs-built_in\">AddOnScreenDebugMessage</span>(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">5.0f</span>, FColor::Blue, __FUNCTION__);<br>\t\t<span class=\"hljs-built_in\">PlayAnimMontage</span>(MeleeAttackMontages[m_iCombo], <span class=\"hljs-number\">1.f</span>, <span class=\"hljs-built_in\">FName</span>(<span class=\"hljs-string\">&quot;Default&quot;</span>));<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>m_bAttack</code> 변수를 주어 그것이 <code>true</code>일 때 클릭하는 경우 콤보상태로 바꾸고 그렇지 않을 경우에는 <code>m_bAttack</code> 상태를 <code>true</code>로 바꾼다음 콤보를 0으로 바꿔준다. </p>\n<p>그 이유는 <code>m_bAttack</code> 상태가 <code>false</code>인 경우 현재 공격이 아닌 다른 애니메이션이 재생되었다가 공격을 하는 거라서 첫번째 애니메이션이 재생이 되어야 한다. 그래서 <code>m_iCombo</code>를 <code>0</code>으로 초기화한 것이다. </p>\n<p>이렇게  <code>m_bAttack</code> 상태를 <code>true</code>로 바꿔서 한번 더 누를 경우 <code>m_bAttack</code>이 <code>true</code>이기 때문에 콤보상태가 <code>true</code>로 바꿔진다.</p>\n<p>그 다음 <code>Itf_ResetCombo_Implementation</code>에서 콤보와 애니메이션을 설정 작업을 해준다.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// MyPlayer.cpp</span><br><br><span class=\"hljs-comment\">//콤보가 리셋될 때 호출 됨.</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">AMyPlayer::Itf_ResetCombo_Implementation</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tGEngine-&gt;<span class=\"hljs-built_in\">AddOnScreenDebugMessage</span>(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">5.0f</span>, FColor::Red, __FUNCTION__);<br><br>\t<span class=\"hljs-keyword\">if</span> (m_bCombo) &#123; <span class=\"hljs-comment\">//콤보 상태일 경우</span><br>\t\t<span class=\"hljs-comment\">//콤보를 1 증가 시킨다.</span><br>\t\tm_iCombo = (m_iCombo + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">3</span>;<br>\t\t<span class=\"hljs-comment\">//다음 애니메이션을 재생시킨다.</span><br>\t\t<span class=\"hljs-built_in\">PlayAnimMontage</span>(MeleeAttackMontages[m_iCombo], <span class=\"hljs-number\">1.f</span>, <span class=\"hljs-built_in\">FName</span>(<span class=\"hljs-string\">&quot;Default&quot;</span>));<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span> &#123; <span class=\"hljs-comment\">//콤보 상태가 아닐 경우</span><br>\t\tm_bAttack = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//공격 상태를 false로 한다.</span><br>\t\tm_bCombo = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//콤보를 취소한다.</span><br>\t\tm_iCombo = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//0으로 초기화한다.</span><br>\t&#125;<br><br>\tm_bCombo = <span class=\"hljs-literal\">false</span>; <span class=\"hljs-comment\">//콤보 상태를 해제 시킨다.</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>그 후 애니메이션이 설정한 시간을 도달하게 되면 함수가 호출된다. 우선 콤보상태일 경우 콤보를 하나 더 증가시킨다.(애니메이션이 종료되기 전에 공격 키를 눌려 콤보를 유지시켰기 때문에) 그 후 증가시킨 인덱스의 애니메이션을 재생시킨다.</p>\n<p>콤보상태가 아닐 경우 설정해둔 변수들을 초기화 시켜준다.(공격이 계속 진행되는 상황이라도 그 공격 애니메이션이 콤보 종료 상태가 들어가기 전에는 한 번 더 조작키를 눌려줘야지 콤보로 인식하기 때문이다.)</p>\n<p>그 후 <code>m_bCombo</code>는 무조건 초기화를 해줘야한다.<br><img src=\"/images/unreal-engine-attack-animation-work-log.md/333.webp\" alt=\"alt text\"></p>\n<p>이렇게 아무리 빨리 눌려도 애니메이션이 끝나야지 다음 애니메이션으로 넘어가게 만들었다. 자연스러운 애니메이션 동작이 확인가능하게 되었다. 짝짝짝-</p>\n<h2 id=\"여담\"><a href=\"#여담\" class=\"headerlink\" title=\"여담\"></a>여담</h2><p>2023.02.29</p>\n<p>오랜만에 옛날 자료를 보다가 잘 정리된 자료를 찾았습니다. 졸업과제 하면서 시행착오도 거치고, 많이 공부했다는 것이 보이네요. 옛날 자료이기는 하지만 누군가가 보고 도움이 되기를 바라면 백업을 해두겠습니다.</p>\n","categories":["과거의 잔재"],"tags":["ue4","animation","game"]},{"title":"Emscripten에서의 Test Suite","url":"/2024/05/16/webassembly-test-suite/","content":"<h2 id=\"TL-DR\"><a href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"></a>TL;DR</h2><p>요즘 Emscripten으로 WASM 작업하고 있는데 동작하나 확인을 하기 위해서는 c++ 코드 작성하고, 자바스크립트 작성 하고, 브라우저 켜서 콘솔창 확인하기 너무 번거로운 것이다. 이왕하는 것 c++ 코드로만 테스트를 진행하고 싶다. 그래서 이것저것 찾아봐서 Google Test를 적용시켜 보았다.</p>\n<h2 id=\"전제-조건\"><a href=\"#전제-조건\" class=\"headerlink\" title=\"전제 조건\"></a>전제 조건</h2><ul>\n<li><a href=\"https://emscripten.org/docs/getting_started/downloads.html\">Emscripten SDK</a>가 설치되어 있고 환경 변수가 구성되어 있어야 합니다.</li>\n</ul>\n<h2 id=\"함수-작성\"><a href=\"#함수-작성\" class=\"headerlink\" title=\"함수 작성\"></a>함수 작성</h2><p>테스트를 진행할 함수를 작성했다.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> a + b; &#125;<br><br><span class=\"hljs-built_in\">EMSCRIPTEN_BINDINGS</span>(my_module) &#123;<br>  <span class=\"hljs-built_in\">function</span>(<span class=\"hljs-string\">&quot;add&quot;</span>, &amp;add);<br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>EMSCRIPTEN_BINDINGS을 사용하여, <code>add</code> 함수가 자바스크립트에서 사용할 수 있게 바인딩 했다. 해당 부분은 <a href=\"https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html#\">Embind</a>를 확인하면 된다.</p>\n<h2 id=\"Test-Suite-작성\"><a href=\"#Test-Suite-작성\" class=\"headerlink\" title=\"Test Suite 작성\"></a>Test Suite 작성</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;emscripten.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;emscripten/val.h&gt;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> emscripten;<br><br><span class=\"hljs-built_in\">TEST</span>(WebTest, Add) &#123;<br>  val Module = val::<span class=\"hljs-built_in\">global</span>(<span class=\"hljs-string\">&quot;Module&quot;</span>);<br>  <span class=\"hljs-type\">double</span> add_result = Module.<span class=\"hljs-built_in\">call</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-string\">&quot;add&quot;</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);<br>  <span class=\"hljs-built_in\">EXPECT_DOUBLE_EQ</span>(<span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">2</span>, add_result);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p><code>Add</code> 함수를 테스트하여 덧셈이 올바른지 확인한다. <code>emscripten::val</code>을 사용하여 C++에서 JavaScript 객체를 호출하고 사용할 수 있다.<br>Embind로 바인딩한 <code>add</code> 함수를 호출해서 사용한다.</p>\n<h2 id=\"CMake-설정\"><a href=\"#CMake-설정\" class=\"headerlink\" title=\"CMake 설정\"></a>CMake 설정</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><code class=\"hljs plaintext\">include(FetchContent)<br>FetchContent_Declare(<br>      googletest<br>      GIT_REPOSITORY https://github.com/google/googletest.git<br>      GIT_TAG v1.14.0<br>)<br><br>FetchContent_MakeAvailable(googletest)<br>include(GoogleTest)<br><br>set(LOPTS &quot;$&#123;LOPTS&#125; -lembind -O3 -std=c++11 -s ASYNCIFY&quot;)<br>set_property(TARGET $&#123;TARGET&#125; PROPERTY SUFFIX &quot;.html&quot;)<br>link_libraries(&quot;-lembind&quot;)<br>target_link_options($&#123;TARGET&#125; PRIVATE &quot;--emrun&quot;)<br>set_target_properties($&#123;TARGET&#125;<br>        PROPERTIES <br>        LINK_FLAGS $&#123;LOPTS&#125;<br>)<br><br>target_link_libraries($&#123;TARGET&#125; PRIVATE gtest_main)<br></code></pre></td></tr></table></figure>\n<p>핵심적인 부분은 <code>FetchContent</code>를 통해 googletest를 설치하고, 사용할 수 있게 하고, emscripten를 위한 링크 플래그를 추가했다.</p>\n<p><code>emrun</code>은 Emscripten으로 생성된 HTML 페이지를 로컬에서 실행하고 디버깅할 수 있게 해주는 도구이다. <code>link_libraries(&quot;-lembind&quot;)</code>를 추가하여 <code>emrun</code> 활성화를 시킨다.<br><code>emrun</code>에 대한 자세한 내용은 <a href=\"https://emscripten.org/docs/compiling/Running-html-files-with-emrun.html\">여기</a>를 참고하면 된다.</p>\n<h2 id=\"실행\"><a href=\"#실행\" class=\"headerlink\" title=\"실행\"></a>실행</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><code class=\"hljs shell\">emrun --browser chrome --browser_args=&quot;--headless --disable-gpu --remote-debugging-port=9222&quot; --kill_exit [HTML]<br></code></pre></td></tr></table></figure>\n<p>해당 명령어를 사용하면 된다. 옵션의 대한 간단한 설명은 다음과 같다.</p>\n<ul>\n<li><code>--browser chrome</code> : 구글 크롬을 사용하여 실행</li>\n<li><code>--browser_args</code> : 크롬 실행 시 추가적으로 전달할 옵션을 지정.</li>\n<li><code>--kill_exit</code> : HTML 실행 후 emrun이 종료될 때까지 대기하지 않고 즉시 종료.</li>\n</ul>\n<p>실행을 하면 테스트함수가 진행되는 것을 볼 수 있다!</p>\n<iframe src=\"https://app.warp.dev/block/embed/UIP3Ibrq5WUVZStq5tD1vm\" title=\"gtest\" style=\"width: 100%; height: 100vh; left: 0; top: 0; border:0; overflow:hidden;\" allow=\"clipboard-read; clipboard-write\"></iframe>\n\n<h2 id=\"Finish\"><a href=\"#Finish\" class=\"headerlink\" title=\"Finish\"></a>Finish</h2><p><a href=\"https://zenn.dev/kounoike/articles/20211129-powerful-wasm-test-env\">ぼくがかんがえたさいきょうのWasm(Emscripten&#x2F;C++)テスト環境</a> 해당 블로그에서 작업한 것을 봤길래 나도 냉큼 따라 해봤다. 생각보다 어렵지 않아서 좋은걸! 특히 자바스크립트와 html을 따로 작성안해서 좋다. 나는 웹 개발이 주가 아니라서 어렵단 말이지..</p>\n<p>더 다양한 것을 하려면 복잡하겠지만, 간단한 작업은 이와 같이 하면 된다. 전체 내용은 <a href=\"https://gist.github.com/keea/d8555d004ac6345bf0c5c88edc0f5757\">gist</a> 올렸으니 확인하면 된다. <code>add</code> 함수 외에 다양한 예시도 있다.</p>\n<h2 id=\"레퍼런스\"><a href=\"#레퍼런스\" class=\"headerlink\" title=\"레퍼런스\"></a>레퍼런스</h2><p>더 자세한 정보를 원하시면 다음 문서를 참고하면 된다.</p>\n<ul>\n<li><a href=\"https://emscripten.org/docs/getting_started/index.html\">Emscripten 공식 문서</a></li>\n<li><a href=\"https://web.dev/articles/embind\">Emscripten’s embind</a></li>\n<li><a href=\"https://zenn.dev/kounoike/articles/20211129-powerful-wasm-test-env\">ぼくがかんがえたさいきょうのWasm(Emscripten&#x2F;C++)テスト環境</a></li>\n</ul>\n","tags":["C++","Emscripten","WebAssembly","Google Test","Test Suite"]}]